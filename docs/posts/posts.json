[
  {
    "path": "posts/2023-06-20-direito-e-inteligncia-artificial/",
    "title": "Resumindo decisões judiciais com o GPT",
    "description": "Mostra como usar o GPT para resumir inteiro teor de decisões judiciais.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://github.com/jjesusfilho"
      }
    ],
    "date": "2023-06-20",
    "categories": [],
    "contents": "\n\n\nIntrodução\nHá uma infinidade de possibilidades para o direito quando se trata de transformers, que são o estado da arte em processamento de linguagem natural. O GPT da Openai é, sem dúvida alguma, o modelo mais bem elaborado de que temos à disposição.\nQuando comecei a tratar do assunto com meus alunos, a primeira reação de muitos foi: “Mas o chatGPT mente…”. Sim, o chatGPT viaja (alucina) às vezes, especialmente quando você pede informações acerca dos dados sobre os quais ele foi treinado.\nNo entanto, muitas das tarefas dos juristas estão relacionadas à extração de dados de peças processuais ou geração de peças com base informações fornecidas ad-hoc. Com efeito, na minha experiência, quando restringimos o GPT a trabalhar com dados fornecidos ad-hoc, ele desempenha muito bem e realiza tarefas relevantes, as quais os humanos detestam fazer. Uma delas é resumir o inteiro teor de decisões judiciais.\nIsso, porém, não lhe dispensa de validar resultados. Geralmente, eu coleto uma amostra dos resultados e verifico se realmente a extração ou resumo são confiáveis.\nAPI da Openai\nPara esse tutorial, usaremos a API da Openai e um dos pacotes do R que a implementa, o pacote openai\nA primeira coisa a fazer é criar uma conta na Openai e, em seguida, criar uma chave. Quando você cria uma conta, a OPENAI oferece U$5.00 para testar. Use esses créditos nesse tutorial.\nAlém disso, você tem de criar uma variável de ambiente para armazenar a chave que você criou. Para tanto, use a função edit_r_environ() do pacote usethis:\nusethis::edit_r_environ()\nAdicione a chave:\nOPENAI_API_KEY=\"sk-....\"\nsalve o arquivo e reinicie o R.\nInstalação dos pacotes necessários\nPara chamar a API, você pode usar o pacote openai:\ninstall.packages(\"openai\")\nNo entanto, para este tutorial, vou pedir que você instale o pacate JurisMiner, o qual contêm uma função, a qual chama a api da OPENAI para resumir inteiro teor de decisões:\ninstall.packages('remotes'). ## Se já não tiver instalado.\nremotes::install_github(\"courtsbr/JurisMiner\")\nAlém disso, instale o pacote tjsp para baixar algumas decisões judiciais a fim de testarmos.\nremotes::install_github(\"jjesusfilho/tjsp\")\nMãos à obra\nCarregue os pacotes:\nlibrary(tidyverse)\nlibrary(tjsp)\nlibrary(JurisMiner)\nIremos baixar apenas dez decisões de primeira instância. As primeiras que aparecerem da busca de julgados de primeiro grau(cjpg):\ndir.create(\"cjpg\")\nbusca <- r\"(\"danos morais\" OU \"dano moral\")\"\ntjsp_baixar_cjpg(livre= busca,\npaginas = 1,\ndiretorio = \"cjpg\")\nDepois disso, leia os dados para o R:\ncjpg <- tjsp_ler_cjpg(diretorio = \"cjpg\")\n\n\n\nBasicamente, esses são os dados retornados:\n\nRows: 10\nColumns: 13\n$ processo         <chr> \"10010631920238260008\", \"100616022202282604…\n$ pagina           <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n$ hora_coleta      <dttm> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA\n$ duplicado        <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, F…\n$ classe           <chr> \"Procedimento do Juizado Especial Cível\", …\n$ assunto          <chr> \"Inclusão Indevida em Cadastro de Inadimple…\n$ magistrado       <chr> \"Roseleine Belver dos Santos Ricci\", \"Gabri…\n$ comarca          <chr> \"SÃO PAULO\", \"Olímpia\", \"Taquarituba\", \"SÃO…\n$ foro             <chr> \"Foro Regional VIII - Tatuapé\", \"Foro de Ol…\n$ vara             <chr> \"1ª Vara do Juizado Especial Cível\", \"2ª Va…\n$ disponibilizacao <date> 2023-06-21, 2023-06-21, 2023-06-21, 2023-06…\n$ julgado          <chr> \"TRIBUNAL DE JUSTIÇA DO ESTADO DE SÃO PAULO…\n$ cd_doc           <chr> \"080018O4B0000-8-PG5REG-147016273\", \"B4000…\n\nNossa tarefa será criar uma nova coluna com o resumo dos julgados. Antes disso, porém, vamos resumir o primeiro julgado. Seguramente, o seu será diferente do meu:\n\n[1] \"TRIBUNAL DE JUSTIÇA DO ESTADO DE SÃO PAULO COMARCA de SÃO PAULO Foro Regional VIII - Tatuapé 1ª Vara do Juizado Especial Cível Rua Santa Maria nº 257, São Paulo - SP - cep 03085-000 1001063-19.2023.8.26.0008 - lauda CONCLUSÃO Em 21 de junho de 2023 Faço estes autos conclusos ao(à) MM(a.). Juiz(a) de Direito Dr(a). Roseleine Belver dos Santos Ricci Eu, , DIEGO CASTANHO LIGUORI, digitei e subscrevi. SENTENÇA Processo nº: 1001063-19.2023.8.26.0008 - Procedimento do Juizado Especial Cível Requerente: Ana Caroline Amaral Cruz Requerido: Sociedade de Ensino Superior Estácio de Sá LTDA Vistos. Trata-se de ação de indenização. Dispensado o relatório nos termos do artigo 38 da Lei 9099/95. O processo comporta julgamento antecipado de seu mérito, perfeitamente possível no âmbito dos Juizados Especiais Civeis. Além de não ter vedação expressa, pois até o art. Lei 9.099/95 fala em julgamento antecipado, cabe ao Magistrado, destinatário da prova, analisar o caso concreto. Sendo assim, entendo que se a conciliação é frustrada na primeira audiência, com defesa já apresentada pelo réu, desnecessidade de produção de prova e ausência de pedido expresso de qualquer das partes para que se realize obrigatoriamente a audiência de instrução e julgamento, é desnecessária a realização de audiência, como no caso. Importa consignar, de pronto, que entre as partes há verdadeira relação de consumo, uma vez que a requerida é fornecedora de serviços, enquanto que o autor é o destinatário final destes. Assim, se o requerente encaixa-se no conceito de consumidor a teor do previsto no Art. 2º da Lei 8.078/90, também é certo que a parte ré igualmente encaixa-se na definição de fornecedora, de acordo com o Art. 3º, daquela mesma lei, uma vez que é pessoa jurídica que desenvolve atividade de comercialização de produtos e/ou serviço no mercado de consumo. Desta forma, aplica-se ao caso em tela o Código de Defesa do Consumidor, o que faz com que o litígio seja inteiramente analisado tendo em vista as regras e princípios que emergem da legislação consumerista, onde a parte autora é, incontestavelmente, vulnerável frente a outra. O pedido é procedente. E ante a hipossuficiência da autora e ante a verossimilhança dos seus argumentos, inverto os ônus da prova, com fundamento no artigo 6º, inciso VIII, do CDC, considerando ainda o porte empresarial da parte requerida. Em face disso, verifico que a requerida não logrou êxito em afastar as alegações da autora no sentido de que sofreu a negativação ilegítima do seu nome, já que relativa a um débito indevido, à medida que foi realizado por um erro no processamento do pedido de cancelamento da matrícula, conforme denota-se pelas conversas realizadas entre a autora e a funcionária da ré (fls. 16/28). Assim, porque indevidas a cobrança do montante informado na exordial, procede o pleito de declaração de inexistência de débitos. Entendo, também, como devida a indenização por danos morais. Inexistindo prova da regularidade da dívida, a negativação perpetrada pela ré foi indevida. Comprovada a negativação indevida do nome da parte autora, os danos morais são presumidos, sendo desnecessária qualquer prova nesse sentido.A propósito: Apelação - Declaratória de inexigibilidade de débito c/c indenização por danos morais - Inscrição indevida do apelado no cadastro de inadimplentes, por suposta habilitação de linha telefônica, não comprovada - Eventual fraude de terceiro não afasta a responsabilidade sobre a negativação indevida - Dano moral in re ipsa, não sendo necessária a demonstração de efetivo prejuízo para a sua caracterização- Negligência por parte da ré - Inexigibilidade do débito e danos morais reconhecidos - Sentença modificada – alor da indenização majorado para R$ 10.000,00 - Recurso do autor parcialmente provido e recurso do réu improvido” (TJSP Apel. nº 0125602-12.2011.8.26.0100, Rel. Luis MarioGalbetti, j. 09/04/2014 VU). É notório que qualquer pessoa inscrita em cadastros de maus pagadores não consegue obter crédito, e nem mesmo emitir um simples cheque. Em suma, fica alijada da prática de atos civis comezinhos por ser considerada uma má pagadora. Impossível deixar de considerar tais consequências como dano moral. Resta assim quantificar o dano. A indenização por dano moral deve ser equivalente à extensão do prejuízo, mas também levar em consideração as condições pessoais das partes envolvidas e o grau de culpa do ofensor. A condenação à indenização por danos morais não pode, servir de pretexto jurídico para gerar o enriquecimento indevido da vítima, mas deve atingir o patrimônio do causador do dano com o intuito salutar e moderado de propiciar a sua reflexão e de evitar a sua reincidência em circunstâncias análogas. Assim, partindo-se do princípio da razoabilidade e da equidade, em casos como o dos autos e consideradas as circunstâncias em que se deram os fatos, mostra-se prudente a fixação do valor do dano moral em R$ 4.000,00 (quatro mil reais). Ante o exposto, JULGO PROCEDENTE O PEDIDO para declarar inexigível o débito indicado na inicial e condenar a parte requerida ao pagamento de indenização à autora por dano moral no valor de R$ 4.000,00 (quatro mil reais), a ser atualizada monetariamente (Tabela do TJSP) a partir desta data e acrescida de juros legais de 1% ao mês desde a citação. Deixo de condenar a vencida nas verbas da sucumbência nos termos do artigo 55, da Lei 9.099/95. a) o prazo para interposição de recurso é de 10 (dez) dias úteis; b) Em caso de recurso, ressalvada a hipótese de concessão de gratuidade da justiça, deverá ser comprovado o recolhimento, sob pena de deserção: b.1) da taxa judiciária de ingresso no importe de 1% sobre o valor ATUALIZADO da causa (observado o valor mínimo de 5 UFESPs); somada a b.2) da taxa judiciária referente às custas de preparo, no importe de 4% sobre o valor ATUALIZADO fixado na sentença ou, se não houver condenação, 4% sobre o valor ATUALIZADO da causa (em ambos os casos observado o valor mínimo de 5 UFESPs). O recolhimento da soma das parcelas “b.1” e “b.2” deverá ser feito em guia DARE-SP, código 230-6 b.3) além das despesas processuais atualizadas referentes a todos os serviços forenses eventualmente utilizados (despesas postais/carta AR unipaginada - guia do F.E.D.T.J. - código 120-1; diligências de Oficial de Justiça - guia GRD; expedição de carta precatória – guia DARE – código 233-1; taxas para pesquisas nos sistemas conveniados, como SISBAJUD, INFOJUD, RENAJUD - guia do F.E.D.T.J. - código 434-1); entre outras, nos termos do Comunicado CG nº 1530/2021 e 489/2022. b.4) Caso haja mídia eletrônica juntada no processo (CD/DVD/pendrive), deverá ser recolhida também a taxa relativa às despesas de porte de remessa e retorno por volume = R$ 43,00 (guia F.E.D.T.J., código 110-4); Dispensada a indicação e publicação do preparo, o recolhimento independe de cálculo elaborado pela serventia, que apenas será responsável pela conferência dos valores, nos termos dos Comunicados CG nº 916/16 e nº 489/2022. c) efetuado o pagamento voluntário mediante depósito judicial, fica desde já deferida a expedição de Mandado de Levantamento Eletrônico em favor do credor, devendo ser indicada a forma pretendida para levantamento ou transferência, o que será certificado no processo após a sua efetivação; d) Após o trânsito em julgado, as partes terão o prazo de 10 (dez) dias corridos para retirar os documentos originais juntados no decorrer do processo, assim como mídias (CD/DVD/pendrive), sob pena de inutilização. e) Com o trânsito em julgado, arquivem-se os autos. P.I.C São Paulo, 21 de junho de 2023. DOCUMENTO ASSINADO DIGITALMENTE NOS TERMOS DA LEI 11.419/2006, CONFORME IMPRESSÃO À MARGEM DIREITA\"\n\nCriando o resumo\nChamaremos a função resumir_inteiro_teor do pacote JurisMiner para ver como fica o resumo.\nresumir_inteiro_teor(cjpg$julgado[1]) |> \ncat()\n\nA decisão judicial proferida pela 1ª Vara do Juizado Especial Cível da Comarca de São Paulo, no processo nº 1001063-19.2023.8.26.0008, julgou procedente o pedido de indenização por danos morais feito pela requerente Ana Caroline Amaral Cruz contra a Sociedade de Ensino Superior Estácio de Sá LTDA. O juiz considerou que houve negativação indevida do nome da autora devido a um erro no processamento do pedido de cancelamento da matrícula. Portanto, declarou a inexigibilidade do débito e condenou a requerida ao pagamento de indenização por danos morais no valor de R$ 4.000,00, além de atualização monetária e juros legais.\n\nNada mal, hein?\nResumindo múltiplos julgados\nPodemos agora chamar a função sobre todo o dataframe:\ncjpg <- cjpg |> \n   mutate(resumo = resumir_inteiro_teor(julgado), .before = julgado)\nglimpse(cjpg)\n\nRows: 10\nColumns: 14\n$ processo         <chr> \"10010631920238260008\", \"100616022202282604…\n$ pagina           <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n$ hora_coleta      <dttm> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA\n$ duplicado        <lgl> FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, F…\n$ classe           <chr> \"Procedimento do Juizado Especial Cível\", …\n$ assunto          <chr> \"Inclusão Indevida em Cadastro de Inadimple…\n$ magistrado       <chr> \"Roseleine Belver dos Santos Ricci\", \"Gabri…\n$ comarca          <chr> \"SÃO PAULO\", \"Olímpia\", \"Taquarituba\", \"SÃO…\n$ foro             <chr> \"Foro Regional VIII - Tatuapé\", \"Foro de Ol…\n$ vara             <chr> \"1ª Vara do Juizado Especial Cível\", \"2ª Va…\n$ disponibilizacao <date> 2023-06-21, 2023-06-21, 2023-06-21, 2023-06…\n$ resumo           <chr> \"A decisão judicial proferida pela 1ª Vara …\n$ julgado          <chr> \"TRIBUNAL DE JUSTIÇA DO ESTADO DE SÃO PAUL…\n$ cd_doc           <chr> \"080018O4B0000-8-PG5REG-147016273\", \"B40005…\n\nVisualizando os resumos\nPara finalizar, vamos visualizar os resumos. Eu adicionei os números dos processos, caso você queira comparar o resumo com o inteiro teor. Note que, a segunda chamada da função resultou em um resumo diferente para o primeiro julgado resumido acima.\npaste(\"Processo: \",cjpg1$processo,\"Resumo:\\n\", cjpg1$resumo)\n\nProcesso: \n10010631920238260008\nResumo:\nA decisão judicial proferida pela 1ª Vara do Juizado Especial Cível da Comarca de São Paulo, no processo nº 1001063-19.2023.8.26.0008, julgou procedente o pedido de indenização por danos morais feito pela requerente Ana Caroline Amaral Cruz contra a Sociedade de Ensino Superior Estácio de Sá LTDA. O juiz considerou que houve negativação indevida do nome da autora devido a um erro no processamento do pedido de cancelamento da matrícula. Assim, declarou a inexigibilidade do débito e condenou a requerida ao pagamento de indenização por danos morais no valor de R$ 4.000,00, além de atualização monetária e juros legais. A parte vencida foi isenta das verbas da sucumbência. Foi concedido prazo de 10 dias úteis para interposição de recurso, com a necessidade de comprovação do recolhimento das taxas judiciárias e demais despesas processuais. Após o trânsito em julgado, os autos serão arquivados.\n\nProcesso: \n10061602220228260400\nResumo:\nA decisão judicial determina que a empresa Planetur Planejamento e Desenvolvimento Urbano e Holding Ltda deve pagar uma indenização de 0,5% do valor atualizado dos contratos aos autores da ação, Matheus Pedroso Bruno e Luis Henrique Motta Buffalo, devido ao atraso na entrega das unidades imobiliárias. O atraso foi de 20 meses, e os valores devidos serão corrigidos monetariamente e acrescidos de juros de mora. A empresa também foi condenada a pagar as custas e despesas processuais, além de honorários advocatícios.\n\nProcesso: \n10003493720218260620\nResumo:\nA decisão judicial determina que a ré, Cia Jaguari Energia, seja obrigada a realizar as adaptações necessárias na rede elétrica para atender a construção de um edifício de propriedade do autor, Saul Pereira. Além disso, a cobrança realizada pela obra é considerada inexigível e a ré deve devolver o valor já adiantado pelo autor. A decisão se baseia no fato de que a ré, como fornecedora de energia, possui responsabilidade objetiva em relação aos danos causados aos consumidores, e não conseguiu comprovar de forma clara e transparente o valor cobrado e a participação devida pelo autor. A decisão também determina o pagamento das custas processuais e honorários advocatícios pela ré.\n\nProcesso: \n10076107820238260007\nResumo:\nA decisão judicial determina que o réu, Grupo Hu Viagens e Turismos S/A (Hotel Urbano), deve indicar novas datas para a realização da viagem mencionada na ação, conforme disponibilidade dos autores, no prazo de 15 dias, sob pena de multa diária. Além disso, o réu deve pagar uma indenização de R$ 3.000,00 por danos morais aos autores, com correção monetária a partir da data da sentença e juros de mora desde a citação. A decisão também informa sobre o prazo para apresentação de recurso e os procedimentos para pagamento das custas processuais.\n\nProcesso: \n10080502220228260068\nResumo:\nA decisão judicial trata de uma ação movida por um motorista de aplicativo contra a empresa Uber. O motorista alega ter sido suspenso definitivamente da plataforma sem justificativa, violando uma lei municipal. No entanto, o juiz considerou que a relação entre as partes é de natureza contratual e não de consumo, e que a empresa tinha o direito de rescindir o contrato de forma unilateral, de acordo com os termos e condições de uso do aplicativo. Portanto, o pedido de reintegração do motorista foi negado. A lei municipal invocada pelo autor não é aplicável nesta comarca. A ação foi julgada improcedente e o processo foi encerrado.\n\nProcesso: \n10284667520228260564\nResumo:\nA decisão judicial determina que o Banco Master S/A (atual denominação do Banco Máxima S/A) restitua ao autor, Rony Anderson Duarte de Souza, os valores descontados indevidamente de seu salário em razão de um empréstimo não solicitado. Além disso, o banco deve pagar uma indenização por danos morais no valor de R$ 5.000,00. A decisão se baseia na falta de provas por parte do banco de que o autor teria solicitado ou concordado com o empréstimo, bem como na falha na prestação de serviços da instituição financeira. O autor também teve deferida a gratuidade de justiça e a antecipação de tutela.\n\nProcesso: \n10020247020228260306\nResumo:\nA decisão judicial determina que a instituição de ensino ré deve cumprir as obrigações assumidas em relação ao pagamento do contrato do FIES firmado pelo autor. Além disso, a ré é condenada a pagar uma indenização por danos morais no valor de R$ 5.000,00 ao autor. A decisão também estabelece que a ré deve arcar com as custas processuais, despesas e honorários advocatícios. Os órgãos de proteção ao crédito devem ser informados para que excluam o nome do autor dos cadastros de devedores. A parte contrária tem o prazo de 15 dias úteis para apresentar recurso de apelação.\n\nProcesso: \n10026758920238260008\nResumo:\nA decisão judicial trata de uma ação de indenização em que o autor alega ter sido negativado indevidamente devido a uma dívida em conta corrente de uma pessoa jurídica da qual ele já não faz parte. O juiz entende que a negativação foi indevida e determina que o réu pague uma indenização por danos morais no valor de R$ 4.000,00. O juiz também destaca que há uma relação de consumo entre as partes e que o Código de Defesa do Consumidor deve ser aplicado ao caso.\n\nProcesso: \n10039030620228260115\nResumo:\nA decisão judicial determina que as requeridas, Facebook Serviços Online do Brasil Ltda. e Telefônica Brasil S.A., sejam condenadas solidariamente a pagar uma indenização por danos morais no valor de R$ 5.000,00 ao autor, Luiz Diego de Oliveira. A ação foi movida pelo autor após ter seu número de celular hackeado e utilizado para aplicar golpes em seus seguidores nas redes sociais. A decisão considerou que as requeridas falharam em garantir a segurança dos serviços prestados, o que resultou em danos à imagem do autor. A sentença também destacou a responsabilidade solidária das empresas envolvidas na cadeia negocial.\n\nProcesso: \n10101717520238260007\nResumo:\nA decisão judicial determina que a parte ré, TAM Linhas Aéreas S/A (LATAM Airlines Brasil), seja condenada a pagar à parte autora, Thagylla de Oliveira Silva, a quantia de R$ 3.280,00, sendo R$ 280,00 por danos materiais e R$ 3.000,00 por danos morais. A responsabilidade da companhia aérea é considerada objetiva, de acordo com o Código de Defesa do Consumidor, e a conduta da ré foi reconhecida como ofensiva à dignidade do consumidor. A decisão ressalta que a indenização tem a função punitivo-pedagógica e visa incentivar a melhora na prestação do serviço. Não há condenação ao pagamento de honorários e custas processuais. As partes são intimadas sobre o prazo para apresentação de recurso e a possibilidade de buscar assistência judiciária da Defensoria Pública.\n\n\n\n\n",
    "preview": {},
    "last_modified": "2023-06-21T14:38:07-03:00",
    "input_file": "direito-e-inteligncia-artificial.knit.md"
  },
  {
    "path": "posts/2023-05-02-webscraping-iterao-com-purrr/",
    "title": "Raspagem de tribunais - Parte 4: iteração com purrr",
    "description": "Este tutorial ensina como iterar sobre várias páginas de consulta em tribunais para coletar e organizar dados de processos judiciais.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://github.com/jjesusfilho"
      }
    ],
    "date": "2023-05-02",
    "categories": [],
    "contents": "\nIntrodução\nNeste tutorial, iremos aprender como iterar em webscraping, ou seja, como realizar múltiplas requisições em páginas de tribunais, quando a consulta retorna mais de uma página. Igualmente, iremos aprender a realizar extrações nas várias páginas baixadas e agregar os resultados.\nIteração no R\nIteração talvez seja uma das tarefas mais elementares e importantes em pragramação. Todas as linguagens de programação permitem iterar por meio de laços de repetição. No R não é diferente e há mais de uma forma de fazer isso. A mais básica delas é vetorização. Por exemplo, se eu tenho um vetor de valores e multiplico este vetor por algum número, estou realizando uma iteração, conhecida como vetorização:\n\n\n1:5*2\n\n[1]  2  4  6  8 10\n\nVeja que eu multipliquei os números de 1 a 5 por 2 e cada um dos valores foi multiplicado. Por trás disso, ocorreu um laço de repetição, mas escrito em linguagem C, que é mais rápida. Você poderia escrever um laço de repetição no R para chegar ao mesmo resultado. No entanto, isso seria mais lento e mais verboso:\n\n\nfor (i in 1:5){\n  \n  print(2*i)\n  \n}\n\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n[1] 10\n\nNote acima que eu usei for seguido de parênteses e dentro deles coloquei a letra i, a qual assumirá os valores de um a cinco a cada laço. Depois dos parênteses, eu abro chaves {} e dentro delas eu coloco tudo o que eu quero que o R faça com o i para alcançar o resultado desejado.\nAlém do for, existe o while, o qual informa o R para realizar uma operação enquanto a condição estabelecida for verdadeira:\n\n\nx <- 1 ## Valor inicial de x\ny <- 0 ## Pode ser qualquer valor. Apenas para que o R saiba que o y existe e é um número.\n\nwhile (y < 20) {  ## Informa o R que a operação deve ser realizada enquanto o y for menor que 20.\n  \n  y <- x^2 ## Altera y a cada laço.\n  \n  print(y) ## Imprime o y alterado.\n  \n  x <- x + 1 ## Adiciona 1 a x para ser usado na próxima iteração.\n}\n\n[1] 1\n[1] 4\n[1] 9\n[1] 16\n[1] 25\n\nIteração com purrr\nNo tidyverse usamos as funções do pacote purrr para iteração sobre objetos. Há dois grupos de funções, o grupo map e o grupo walk. O primeiro retorna um objeto R, o segundo não retorna objeto algum e é útil para efeitos colaterais, como salvar arquivos ou gerar gráficos de forma interativa. Carregue o tidyverse, o httr e o xml2.\n\n\nlibrary(tidyverse)\nlibrary(httr)\nlibrary(xml2)\n\n\nSintaxe básica do map\nBasicamente, o primeiro argumento do map é o objeto, que pode ser um vetor ou uma lista de elementos. O segundo é uma função anônima, criada com ~ (til), \\(x) ou function(x), a qual será aplicada sobre cada objeto e, dentro dela, .x (ponto x). Este representa cada elemento do objeto:\nmap(objeto, ~funcao(.x, ...)) # As reticências (ellipsis) indicam eventais outros argumentos.\nOutras sintaxes:\nVocê também pode chamar o map e colocar a função, ou um codigo dentro de chaves:\nmap(objeto, ~{\n  funcao(.x,...)\n})\nVocê pode chamar uma função anônima de forma ainda mais explícita:\nmap(objeto, function(x)(funcao(.x)))\nAlguns exemplos:\n\n\nmap(c(4,9,16,25), ~sqrt(.x))\n\n[[1]]\n[1] 2\n\n[[2]]\n[1] 3\n\n[[3]]\n[1] 4\n\n[[4]]\n[1] 5\n\n\n\nmap(c(4,9,16,25), ~{ \n  sqrt(.x)\n  })\n\n[[1]]\n[1] 2\n\n[[2]]\n[1] 3\n\n[[3]]\n[1] 4\n\n[[4]]\n[1] 5\n\n\n\nmap(c(4,9,16,25), function(x) sqrt(x))\n\n[[1]]\n[1] 2\n\n[[2]]\n[1] 3\n\n[[3]]\n[1] 4\n\n[[4]]\n[1] 5\n\n\n\nmap(c(4,9,16,25), ~.x |> sqrt())\n\n[[1]]\n[1] 2\n\n[[2]]\n[1] 3\n\n[[3]]\n[1] 4\n\n[[4]]\n[1] 5\n\nQuanto é uma função só, o til (~) e o .x são dispensáveis:\n\n\nmap(c(4,9,16,25), sqrt)\n\n[[1]]\n[1] 2\n\n[[2]]\n[1] 3\n\n[[3]]\n[1] 4\n\n[[4]]\n[1] 5\n\nVocê também pode usar a nova notação do r \\(x)\n\n\nmap(c(4,9,16,25), \\(x) sqrt(x))\n\n[[1]]\n[1] 2\n\n[[2]]\n[1] 3\n\n[[3]]\n[1] 4\n\n[[4]]\n[1] 5\n\nVariações do map\nNos exemplos acima, o map gerou uma lista. No entanto, nem sempre queremos uma lista. Se quisermos um vetor, temos de especificar o tipo de retorno com as variações do map. São elas:\nmap_chr: retorna um vetor de caracteres\nmap_dbl: retorna um vetor de flutuantes (doubles)\nmap_int: retorna um vetor de inteiros\nmap_lgl: retorna um vetor de valores lógicos\nmap_dfr: retorna um dataframe resultado do empilhamento (junção vertical) de outros dataframes.\nmap_dfc: retorna uma dataframe resultado de emparalhamento (junção horizontal) de outros dataframes\nNo exemplo acima, melhor seria se utilizássemos map_dbl:\n\n\nmap_dbl(c(4,9,16,25), sqrt)\n\n[1] 2 3 4 5\n\nEm jurimetria, nós usamos muito a funcão map_dfr para juntar os dataframes gerados a partir da extração dos dados de cada página baixada numa busca. Cada página de busca em tribunal, geralmente contêm 10, 15 ou 20 julgados. Isso significa que cada página gerará um dataframe com esses respectivos números de linhas. A função map_dfr junta todos esses dataframes em um, após a iteração, ou seja, ela itera e junta tudo de uma vez só.\nWalk\nWalk tem a mesma sintaxe, mas não retorna objetos. Ele é útil quando queremos baixar várias páginas no disco. Se você tentar fazer o mesmo com walk, veja o que acontece, ou melhor, o que não acontece:\n\n\nwalk(c(4,9,16,25), ~sqrt(.x))\n\n\nMas você pode salvar em disco. Tente reproduzir o exemplo abaixo e verificar que nada foi gerado na área de trabalho, nem no console, mas foram salvos cinco arquivos no seu diretório atual.\nwalk(c(4,9,16,25), ~sqrt(.x) |> cat(file = paste0(\"raiz_de_\", .x, \".txt\")))\nMais variações de map e de walk\nHá uma segunda versão para todos verbos acima: map2, map2_chr, map2_dbl, map2_int, map2_lgl, map2_dfr, map2_dfc e walk2. Elas permitem iterar sobre dois objetos do mesmo tamanho. Vejamos um exemplo:\n\n\nmap2_chr(1:5, letters[1:5], ~paste(.x, .y)) # O primeiro objeto é representado em cada iteração por .x e o segundo por .y\n\n[1] \"1 a\" \"2 b\" \"3 c\" \"4 d\" \"5 e\"\n\nMais variações: múltiplos objetos: pmap e pwalk.\nQuando precisar iterar em mais de dois objetos, você coloca p antes de qualquer desses verbos. No entanto você precisa colocar o objeto em uma lista e usar function(x,y, z, w, …) ou os nomes de cada elemento da lista. Vejamos:\n\n\nlista <- list(x = 1:5, y = letters[1:5], z = c(\"I\",\"II\",\"III\",\"IV\",\"V\"))\n\npmap_chr(lista, function(x,y, z) paste(x,y,z, sep = \"-\"))\n\n[1] \"1-a-I\"   \"2-b-II\"  \"3-c-III\" \"4-d-IV\"  \"5-e-V\"  \n\nIterando requisições\nAgora que aprendemos como fazer iterações com purrr, vamos realizar várias iterações sobre uma consulta de primeiro grau no TJSP. Abaixo o passo a passo:\nRealizar a consulta diretamente na página.\nCopiar a url e, se necessário, o corpo e os headers.\nCriar objetos para a url e para os headers.\nFazer a primeira requisição.\nVerificar o número total de registos e quantos por página.\nCriar o xpath para extrair o total de registros.\nClicar na próxima página para ver se a query, em caso de GET, ou corpo, quando for POST, são alterados. Criar um objeto no R com essas alterações.\nUsar walk para realizar tantas requisições quantas necessárias.\nSalvar cada requisição em um arquivo diferente.\nConsulta à página\nEntre na página de consulta de primeiro grau do tjsp, aqui e faça uma consulta qualquer. Eu irei consultar a a palavra “escafandro”, simplesmente porque ela retornou, no momento da consulta, apenas 24 registros contidos em três páginas.\nCopiar a url e criar um objeto\nCopie a url da barra de endereços do navegador ou a partir do cabeçalho geral e cole no seu script como eu fiz abaixo. Lembre-se de clicar com o botão direito do mouse, selecionar inspect e refazer a consulta.\n\n\nurl <- \"https://esaj.tjsp.jus.br/cjpg/pesquisar.do?conversationId=&dadosConsulta.pesquisaLivre=escafandro&tipoNumero=UNIFICADO&numeroDigitoAnoUnificado=&foroNumeroUnificado=&dadosConsulta.nuProcesso=&dadosConsulta.nuProcessoAntigo=&classeTreeSelection.values=&classeTreeSelection.text=&assuntoTreeSelection.values=&assuntoTreeSelection.text=&agenteSelectedEntitiesList=&contadoragente=0&contadorMaioragente=0&cdAgente=&nmAgente=&dadosConsulta.dtInicio=&dadosConsulta.dtFim=30%2F04%2F2023&varasTreeSelection.values=&varasTreeSelection.text=&dadosConsulta.ordenacao=DESC\"\n\n\nPrimeira requisição\nRealize a primeira requisição e verifique se a resposta está ok.\n\n\nr1 <- GET(url)\nr1\n\nResponse [https://esaj.tjsp.jus.br/cjpg/pesquisar.do?conversationId=&dadosConsulta.pesquisaLivre=escafandro&tipoNumero=UNIFICADO&numeroDigitoAnoUnificado=&foroNumeroUnificado=&dadosConsulta.nuProcesso=&dadosConsulta.nuProcessoAntigo=&classeTreeSelection.values=&classeTreeSelection.text=&assuntoTreeSelection.values=&assuntoTreeSelection.text=&agenteSelectedEntitiesList=&contadoragente=0&contadorMaioragente=0&cdAgente=&nmAgente=&dadosConsulta.dtInicio=&dadosConsulta.dtFim=30%2F04%2F2023&varasTreeSelection.values=&varasTreeSelection.text=&dadosConsulta.ordenacao=DESC]\n  Date: 2023-05-02 18:06\n  Status: 200\n  Content-Type: text/html;charset=UTF-8\n  Size: 401 kB\n\n\n\n\n\n\n\n\n\n\n...\n\nSe para você apareceu status 200, siga adiante. Se não, verifique se seguiu os passos corretamente.\nExtração do número de registro.\nO próximo passo é extrair o número de registro da página obtida. Para tanto, usamos XPATH.\n\n\nregistros <- r1 |> \n           content() |> \n           xml_find_first(\"//tr[@height='20']/td\") |> \n           xml_text(trim = T) |> \n          stringr::str_extract(\"\\\\d+$\")\n\n\nPara saber sobre quantas páginas iterar, basta dividir por 10 e arredondar para cima:\n\n\ndividir <- `/`\npaginas <- registros |> \n       as.integer() |> \n       dividir(10) |> \n       ceiling()\n\n\nPróximas páginas\nRetorne à consulta e clique em próxima página, com o inspector aberto. Copie a url. Note abaixo que na url, há o número da página, mas os demais parâmetros, inclusive a consulta, não aparecem. De fato, não precisamos porque na consulta anterior, recebemos também um cookie, que mantêm a memória da requisição.\n\n\nurl2 <- \"https://esaj.tjsp.jus.br/cjpg/trocarDePagina.do?pagina=2&conversationId=\"\n\n\nComo temos de iterar sobre as páginas, a url acima deve ser reescrita a cada requisição. A função vem a calhar. Podemos já criar todas as urls ou deixar para criar uma a uma dentro da função walk. As urls ficarão assim:\n\n\nurls <- paste0(\"https://esaj.tjsp.jus.br/cjpg/trocarDePagina.do?pagina=\",1:paginas,\"&conversationId=\")\nurls\n\n[1] \"https://esaj.tjsp.jus.br/cjpg/trocarDePagina.do?pagina=1&conversationId=\"\n[2] \"https://esaj.tjsp.jus.br/cjpg/trocarDePagina.do?pagina=2&conversationId=\"\n[3] \"https://esaj.tjsp.jus.br/cjpg/trocarDePagina.do?pagina=3&conversationId=\"\n\nNo entanto, é melhor colocar no walk os números das páginas, assim usamos esses números para montar as urls e para gerar os nomes dos arquivos.\nPronto, podemos colocar tudo dentro de um walk. Só não podemos esquecer de gerar um arquivo para cada requisição. Não se esqueça de realizar novamente a requisição inicial, pois a sessão já expirou.\nr1 <- GET(url) \nwalk(1:paginas,~{\n  \n  arquivo <- paste0(\"cjpg_pagina_\", .x, \".html\")\n  \n  url <- paste0(\"https://esaj.tjsp.jus.br/cjpg/trocarDePagina.do?pagina=\",.x,\"&conversationId=\")\n  \n  GET(url, write_disk(arquivo, overwrite = T))\n  \n})\nVerifique no diretório que todas as páginas foram salvas. Terminamos o processo. No entanto, precisamos organizar tudo isso dentro de uma função para que o próprio usuário forneça os termos de busca. Vamos parsear a url para ver quais argumentos os usuários deverão fornecer.\n\n\nparse_url(url)\n\n$scheme\n[1] \"https\"\n\n$hostname\n[1] \"esaj.tjsp.jus.br\"\n\n$port\nNULL\n\n$path\n[1] \"cjpg/pesquisar.do\"\n\n$query\n$query$conversationId\n[1] \"\"\n\n$query$dadosConsulta.pesquisaLivre\n[1] \"escafandro\"\n\n$query$tipoNumero\n[1] \"UNIFICADO\"\n\n$query$numeroDigitoAnoUnificado\n[1] \"\"\n\n$query$foroNumeroUnificado\n[1] \"\"\n\n$query$dadosConsulta.nuProcesso\n[1] \"\"\n\n$query$dadosConsulta.nuProcessoAntigo\n[1] \"\"\n\n$query$classeTreeSelection.values\n[1] \"\"\n\n$query$classeTreeSelection.text\n[1] \"\"\n\n$query$assuntoTreeSelection.values\n[1] \"\"\n\n$query$assuntoTreeSelection.text\n[1] \"\"\n\n$query$agenteSelectedEntitiesList\n[1] \"\"\n\n$query$contadoragente\n[1] \"0\"\n\n$query$contadorMaioragente\n[1] \"0\"\n\n$query$cdAgente\n[1] \"\"\n\n$query$nmAgente\n[1] \"\"\n\n$query$dadosConsulta.dtInicio\n[1] \"\"\n\n$query$dadosConsulta.dtFim\n[1] \"30/04/2023\"\n\n$query$varasTreeSelection.values\n[1] \"\"\n\n$query$varasTreeSelection.text\n[1] \"\"\n\n$query$dadosConsulta.ordenacao\n[1] \"DESC\"\n\n\n$params\nNULL\n\n$fragment\nNULL\n\n$username\nNULL\n\n$password\nNULL\n\nattr(,\"class\")\n[1] \"url\"\n\nAlém da busca livre, é possível buscar por número do processo, pela data, pelo assunto, pela vara e pela classe processual. Não utilizaremos o número do processo, pois se sabemos ele, não faz sentido prencher os demais nem realizar várias requisições, a menos que sejam fornecidos vários números de processo. Montaremos a função com os demais argumentos.\nQuando usamos chamamos funções de pacotes dentro de nossa função, devemos qualificá-las com o nome do pacote: pacote::funcao. Isso é mais seguro, informativo e não é nada recomendável você carregar pacotes inteiros dentro de uma função.\n\nbaixar_cjpg <- function(\n                       ## Todos os argumentos serão como default vazios, a menos que o usuário forneça o valor \n                        livre = \"\",\n                        classe = \"\",\n                        assunto = \"\",\n                        dt_inicio = \"\",\n                        dt_fim = \"\",\n                        vara = \"\"\n                        diretorio = \".\" ### O diretório será \".\", i.e, baixa no diretório atual, a menos que você especifique.\n                        ){\n\n### Usei a funcão parse_url do pacote httr para converter a url em lista. Assim, posso alocar os valores de busca em cada elemento da lista. Confira abaixo.\n\nurl_parseda1 <-  \n  structure(list(\n    scheme = \"https\",\n    hostname = \"esaj.tjsp.jus.br\",\n    port = NULL,\n    path = \"cjpg/pesquisar.do\",\n    query = list(\n      conversationId = \"\",\n      dadosConsulta.pesquisaLivre =  livre,\n      tipoNumero = \"UNIFICADO\",\n      numeroDigitoAnoUnificado = \"\",\n      foroNumeroUnificado = \"\",\n      dadosConsulta.nuProcesso = \"\",\n      dadosConsulta.nuProcessoAntigo = \"\",\n      classeTreeSelection.values = classe,\n      classeTreeSelection.text = \"\",\n      assuntoTreeSelection.values = assunto,\n      assuntoTreeSelection.text = \"\",\n      agenteSelectedEntitiesList = \"\",\n      contadoragente = \"0\",\n      contadorMaioragente = \"0\",\n      cdAgente = \"\",\n      nmAgente = \"\",\n      dadosConsulta.dtInicio = dt_inicio,\n      dadosConsulta.dtFim = dt_fim,\n      varasTreeSelection.values = vara,\n      varasTreeSelection.text = \"\",\n      dadosConsulta.ordenacao = \"DESC\"\n    ),\n    params = NULL,\n    fragment = NULL,\n    username = NULL,\n    password = NULL\n  ),\n  class = \"url\"\n)\n\n### Parseei a url de busca por páginas também. Coloquei \"\" em pagina.\n\nurl_parseda2 <- structure(\n  list(\n    scheme = \"https\",\n    hostname = \"esaj.tjsp.jus.br\",\n    port = NULL,\n    path = \"cjpg/trocarDePagina.do\",\n    query = \n    list(\n         pagina = \"\",\n         conversationId = \"\"\n         ),\n    params = NULL,\n    fragment = NULL,\n    username = NULL,\n    password = NULL\n  ),\n  class = \"url\"\n)\n\n### O pipe do R base não aceita infix (/). Precisamos convertê-lo em função.\n\ndividir <- `/`\n\n### Agora é só fazer a requisição, extrair o número de registros e dividir por 10.\npaginas <- url_parseada |> \n          httr::build_url() |> ## reconstrói a \n          httr::GET() |> \n          httr::content() |> \n          httr::xml_find_first(\"//tr[@height='20']/td\") |> \n          httr::xml_text(trim = T) |> \n          stringr::str_extract(\"\\\\d+$\") |> \n          as.integer() |> \n          dividir(10) |> \n          ceiling()\n          \n### Podemos, enfim, iterar, ou seja, realizar a requisição por página.\n\npurrr::walk(1:paginas, ~{\n\nurl_parseada2$query$pagina <- .x\n\nurl <- httr::build_url(url_parseada2)\n\narquivo <- file.path(diretorio, paste0(\"cjpg_pagina_\", .x,\".html\"))\n\nurl |> \n   httr::GET(httr::write_disk(arquivo, overwrite = TRUE))\n\n})\n\n} \n\n\n\n",
    "preview": {},
    "last_modified": "2023-05-02T15:06:27-03:00",
    "input_file": "webscraping-iterao-com-purrr.knit.md"
  },
  {
    "path": "posts/2023-05-02-extracaocomxpath/",
    "title": "Raspagem nos tribunais - Parte 3: extração com XPATH",
    "description": "Neste terceiro tutorial, eu mostro como extrair dados de páginas web baixadas dos tribunais usando uma ferramenta poderosa como xpath.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://github.com/jjesusfilho"
      }
    ],
    "date": "2023-05-02",
    "categories": [],
    "contents": "\nIntrodução\nNeste tutorial veremos como usar xpath para extrair dados de um html. Ele faz parte de uma série de tutorias voltados à raspagem de dados de tribuanis com R. Assim como expressões regulares, xpath requer tempo para dominá-lo. Para iniciar, falaremos de html, pois ele é a base sobre a qual xpath opera. Veja o exemplo abaixo.\nExemplo de html\n\n\nx  <- '<html>\n     <head>\n         <meta charset=\"utf-8\">\n     <\/head>\n     <body>\n         <div class=\"julgado\">\n             <a href=\"https://link_para_documento\"><\/a>\n            <div class=\"processo\">1234567-23.2022.8.26.0000<\/div>\n            <div class=\"assunto\">Dano moral<\/div>\n            <div class=\"colegiado\">\n                  Relator: fulano de tal\n                  <br>\n                  Revisor: Sicrano\n                  <br>\n                  Presidente: Beltrano\n            <\/div>\n            <div class=\"classe processual\">Procedimento Comum Cível<\/div>\n         <\/div>\n      <\/body>\n  <\/html>'\n\n\nO exemplo acima, o qual chamaremos de documento, inicia com o elemento ou tag <html> e termina com<\/html>. Essa é a sintaxe básica. O mesmo elemento que abre, fecha. Por vezes o encerramento é dispensável, quando entre os dois não vai nada. Por exemplo,<br> indica apenas quebra de linha.\nLogo após o <html>, há outra tag <head> e dentro desta, outra tag. No mesmo nível do <head>, há a tag <body> e dentro desta pode haver um número indefinido de tags filhas. Toda tag que contêm outras é chamada de tag mãe ou pai e a tag contida chamada de filha. Uma tag pode ser mãe e filha.\nAdicionalmente às tags, existem os atributos. Estes qualificam as tags e individualizam a informação. Essa individualização permite que uma outra linguagem, CSS, agrege aspectos estéticos ao documento. Os atributos vêm com um valor. Em um dos exemplos acima, o atributo classe contêm o valor “processo”.\nEsses atributos e tags são marcadores sobre os quais navegamos, com a ajuda de xpath, para extrair as informações desejadas.\nNoções de xpath\nXPath é uma linguagem de consulta que permite navegar por documentos que usam marcadores, como os arquivos XML e HTML. XPath significa XML Path Language. Para extrar dados de um documento html, você precisa conhecer alguns metacaracteres que lhe permitam navegar. Veja abaixo:\n/ indica o nó raiz\n// indica um nó em qualquer lugar do documento\n. indica o nó atual\n.. indica o nó pai do nó atual\n/@ indica um atributo\n//tag/following-sibling::tag Manda para uma específica no mesmo nível da atual.\n//tag/parent::tag Manda para uma tag pai específica.\n//* indica qualquer elemento ou atributo\nPor exemplo, a expressão XPath /html/body/p seleciona todos os elementos <p> que são filhos do elemento <body> que é filho do elemento <html>. Esta expressão, por outro lado, indica um caminho absoluto, pois usa barra única. Isso significa que esta ordem é estrita, o primeiro elemento é html, logo abaixo dele tem o body e logo abaixo deste tem o p.\nPara indicar caminho relativo, ou seja, procurar o elemento independentemente se ele é filho, neto, bisneto etc, usamos barras duplas //. Por exemplo, se fizermos //p, iremos nos posicionar em todos os elementos p que estejam no mesmo nível daquele foi encontrado pela primeira vez.\nAlém disso, xpath possui verbos e outros indicadores. Por vezes, o próprio conteúdo pode ser considerado um elemento. Mais adiante, iremos dar exemplos.\nO R possui um pacote que permite navegar por html e extrair as informações desejadas. O nome dele é xml2. Vamos trabalhar no exemplo acima que foi associado ao objeto x.\n\n\nlibrary(xml2) ### Carregue o pacote xml2\n\ndoc <- x |> \n    read_html() ## importa para o R o html com a classe xml_document.\n\n\nA primeira coisa a fazer é ler o html para o R usando a função read_html(). O objeto x era um mero texto, poderia ser um arquivo html. Ao lê-lo com read_html, convertemos em xml_document. Somente agora podemos aplicar xpath.\n\n\ndoc |> \n  xml_find_all(\"/*\") |> ### Encontra o elemento \n  xml_text() |> ## Extrai o texto dentro deste elemento.\n  cat() ## Usado apenas para uma visualização amigável.\n\n\n         \n             \n            1234567-23.2022.8.26.0000\n            Dano moral\n            \n                  Relator: fulano de tal\n                  \n                  Revisor: Sicrano\n                  \n                  Presidente: Beltrano\n            \n            Procedimento Comum Cível\n         \n      \n\nNo exemplo acima, eu usei “/*“, ou seja, posicione no documento inteiro. Depois disso, eu usei xml_text() para extrair todo o conteúdo textual do documento. Usei cat() apenas para uma visualização agradável.\nAgora vamos extrair apenas o número do processo:\n\n\ndoc |> \n  xml_find_all(\"//div[@class='processo']\") |> \n  xml_text()\n\n[1] \"1234567-23.2022.8.26.0000\"\n\nNote que eu usei o caminho relativo “//div”, ou seja, saltei diretamente para o primeiro div do documento. No entanto, há mais divs irmãos desse div, então eu preciso informar que quero apenas o div que contenha o processo. Para tanto, uso [@class='processo'], ou seja, vá para a div que contenha o atributo class cujo valor é processo.\nAgora vamos pegar o assunto:\n\n\ndoc |> \n  xml_find_all(\"//div[@class='assunto']\") |> \n  xml_text()\n\n[1] \"Dano moral\"\n\nPor vezes, não há um atributo que distinga claramente um conteúdo. Vamos supor que não tenha nenhum atributo indicando o assunto, apenas indicando o processo. Podemos informar ao xpath que queremos o conteúdo do div que vem logo depois do div do processo:\n\n\ndoc |> \n  xml_find_all(\"//div[@class='processo']/following-sibling::div[1]\") |>  \n  xml_text()\n\n[1] \"Dano moral\"\n\nNote que eu fui até o div do processo e, em seguida, usei following-sibling::div, ou seja, pegue o irmão seguinte que se chama div.\nAgora vamos supor que eu queira todos as categorias, ou seja, os valores dos atributos: processo, assunto, colegiado e classe processual, e não o conteúdo:\n\n\ndoc |> \n  xml_find_all(\"//div/div\") |> \n  xml_attr(\"class\")\n\n[1] \"processo\"          \"assunto\"           \"colegiado\"        \n[4] \"classe processual\"\n\nNote que eu fui até o div filho de um div e, em vez de usar xml_text(), usei xml_attr(“class”) para indicar que quero o atributo e não o conteúdo.\nOutra maneira de atingir o mesmo objetivo é:\n\n\ndoc |> \n  xml_find_all(\"//div/div/@class\") |> \n  xml_text()\n\n[1] \"processo\"          \"assunto\"           \"colegiado\"        \n[4] \"classe processual\"\n\nNo exemplo acima, eu converti o atributo em elemento e extraí o conte údo dele com xml_text().\nHá situações em que eu quero caminhar para trás. por exemplo, vamos pegar a irmã anterior do assunto, ou seja, processo:\n\n\ndoc |> \n  xml_find_all(\"//div[@class='assunto']/preceding-sibling::div\") |> \n  xml_text()\n\n[1] \"1234567-23.2022.8.26.0000\"\n\nNote que usei preceding-sibling para atingir meu objetivo.\nPor vezes queremos obter o conteúdo do pai de um elemento. Por exemplo, podemos extrair o link do inteiro teor desta forma, sem recorrer ao pai:\n\n\ndoc |> \n  xml_find_all(\"//div/a\") |> \n  xml_attr(\"href\")\n\n[1] \"https://link_para_documento\"\n\nOutra maneira de fazer isso, é recorrer ao indicador pai:\n\n\ndoc |> \n  xml_find_all(\"//div[@class='processo']/../a\") |> \n  xml_attr(\"href\")\n\n[1] \"https://link_para_documento\"\n\nNote que eu fui até a div do processo e usei .. (dois pontinhos) para voltar à mãe desse div e caminhar até a tag a.\nOutra forma:\n\n\ndoc |> \n  xml_find_all(\"//div[@class='processo']/parent::div/a\") |> \n  xml_attr(\"href\")\n\n[1] \"https://link_para_documento\"\n\nEsta forma é mais precisa, especialmente quando queremos um avô ou bisavô mais distante.\nPor fim, vamos dar um exemplo em que queremos extrair apenas o relator, ou seja o primeiro texto do colegiado.\n\n\ndoc |> \n  xml_find_all(\"//div[@class='colegiado']/text()[following-sibling::br][1]\") |> \n  xml_text()\n\n[1] \"\\n                  Relator: fulano de tal\\n                  \"\n\nVeja que eu usei o texto como como tag. Encontrei todo os textos dentro de colegiado seguidos de quebra de linha <br>, mas retive apenas o primeiro.\nSe eu quiser o revisor;\n\n\ndoc |> \n  xml_find_all(\"//div[@class='colegiado']/text()[following-sibling::br][2]\") |> \n  xml_text()\n\n[1] \"\\n                  Revisor: Sicrano\\n                  \"\n\nIsso já não funcionaria com o presidente, pois ele não é seguido de br. Para tanto, precido pensar num artifício. Vou até o texto que tem duas quebras de linha antes dele:\n\n\ndoc |> \n  xml_find_all(\"//div[@class='colegiado']/text()[preceding-sibling::br][2]\") |> \n  xml_text()\n\n[1] \"\\n                  Presidente: Beltrano\\n            \"\n\nEm todos os casos acima, eu usei xml_find_all porque geralmente estou buscando várias ocorrência numa mesma página. No entanto, como havia uma só ocorrência, eu deveria ter usado xml_find_first.\nPor fim, nos últimos exemplos, o resultado veio com quebra de linha e espaços extras, eu posso eliminá-los usando o argumento trim = TRUE.\n\n\ndoc |> \n  xml_find_all(\"//div[@class='colegiado']/text()[preceding-sibling::br][2]\") |> \n  xml_text()\n\n[1] \"\\n                  Presidente: Beltrano\\n            \"\n\n\n\n\n",
    "preview": {},
    "last_modified": "2023-05-02T15:37:36-03:00",
    "input_file": "extracaocomxpath.knit.md"
  },
  {
    "path": "posts/2023-04-26-raspagem-de-tribunais-requisio-http/",
    "title": "Raspagem de tribunais: requisição http.",
    "description": "Este tutorial introduz os principais elementos de uma requisição http e como realizá-la em tribunais de justiça e administrativos.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://github.com/jjesusfilho"
      }
    ],
    "date": "2023-04-26",
    "categories": [],
    "contents": "\nIntrodução\nNeste tutorial, mostro como realizar requisições http. Ele é parte de material de apoio para o curso de raspagem de tribunais de justiça e administrativos.\nOs principais conceitos do protocolo http são apresentados. Antes de iniciar, vamos instalar um pacote muito importante para realizar requisições http, o pacote httr. Falaremos desse pacote extensivamente ao longo desse e dos demais tutoriais.\ninstall.packages(\"httr\")\nAlém do pacote httr, há um outro pacote, que eu mantenho, chamado JurisMiner. Ele possui algumas funções auxiliares na requisição. Instale ele também:\nremotes::install_github(\"courtsbr/JurisMiner\")\nCarregue os dois pacotes:\n\n\n\nRequisição http\nQuando você escreve o endereço ou url de uma página na barra de endereços do seu navegador, uma série de ações acontecem e muitas informações são transmitidas entre seu computador (cliente) e o computador de quem hospeda a página consultada (servidor).\nEssa transmissão de dados entre o servidor que hospeda a página e o seu navegador é controlada pelo protocolo http (Hypertext Transfer Protocol). O protocolo http assegura uma transmissão de dados segura e íntegra.\nA esse processo de abrir uma página e visualizar os dados carregados, chamamos de requisição http. A requisição http possui partes, que basicamente são a url, os headers ou cabeçalhos e o corpo.\nAlém das partes, existe que é a ação ou método de requisição. Há vários métodos de requisição conhecidos, mas dois são de especial relevância para web scraping: GET e POST.\nMétodos\nGET: O mais comum e serve para requisitar uma representação do recurso desejado. Quando você acessa uma página pela barra de endereço do navegador, geralmente você está usando o GET.\nPOST: Serve para requisitar uma representação recurso também, mas fornece um conjunto de informações que servirão para o processamento do dado ou para serem armazenadas pelo servidor. A requisição POST sempre vem acompanhada do corpo(body), o qual consiste basicamente num formulário, similar à query.\nURL\nA URL é o endereço que você digita no seu navegador ou outro endereço gerado a partir da interação com, e.g., uma página de busca. Por exemplo, se você acessar a página de busca de julgados de primeiro grau do TJSP e fizer uma busca qualquer verá que o endereço (url), após a busca, é composto de vários componentes, os quais descreveremos abaixo:\nScheme: A versão do protocolo http usada (http, https..)\nHostname: O nome de quem hospeda a página e os dados. No presente caso é: esaj.tjsp.jus.br, ou seja, um subdomínio (esaj) do tjsp.jus.br (domínio).\nport: A porta que permite acesso ao conteúdo. Geralmente esta não é informada diretamente a você, pois ela é conhecida. Geralmente 543 para https e 80 para http.\npath: Este é o caminho ou subdiretório no servidor onde se encontram as informaçoes ou, ao menos, onde o acesso aos recursos é gerenciado.\nquery: Essa é uma lista longa de informações na forma chave=valor. Ela vem depois de um sinal de interrogação e é composta por informações que o cliente (você) presta ao servidor para que ele opere alguns filtros necessários e fornecer os dados buscados.\nOutros componentes: eventualmente, alguns componenentes como params, username, password e fragment são requeridos, mas são excepcionais e dificilmente encontraremos um caso na área jurídica.\nPara ajudar com um exemplo, vá para a consulta processual do TJSP neste link e realize uma consulta qualquer. Irei realizar uma pesquisa pelo nome do advogado: Fulano de Tal. Após clicar em Consultar, a barra de endereços do navegador mostrará o seguinte endereço (role a barra para ver o endereço completo)\nhttps://esaj.tjsp.jus.br/cpopg/search.do?conversationId=&cbPesquisa=NMADVOGADO&dadosConsulta.valorConsulta=fulano de tal&cdForo=-1\nA URL acima contêm os seguintes compontes:\nscheme: https\nhostname: esaj.tjsp.jus.br\nsubdomínio: esaj\nnome ou domínio de segundo nível: tjsp\nextensão ou domínio de primeiro nível: jus\npaís: br\n\npath ou subdiretório: cpopg/search.do\nquery ou consulta: conversationId=&cbPesquisa=NMADVOGADO&dadosConsulta.valorConsulta=fulano de tal&cdForo=-1\nO pacote httr possui uma função importante para desagregar a url em seus componentes:\n\n$scheme\n[1] \"https\"\n\n$hostname\n[1] \"esaj.tjsp.jus.br\"\n\n$port\nNULL\n\n$path\n[1] \"cpopg/search.do\"\n\n$query\n$query$conversationId\n[1] \"\"\n\n$query$cbPesquisa\n[1] \"NMADVOGADO\"\n\n$query$dadosConsulta.valorConsulta\n[1] \"fulano de tal\"\n\n$query$cdForo\n[1] \"-1\"\n\n\n$params\nNULL\n\n$fragment\nNULL\n\n$username\nNULL\n\n$password\nNULL\n\nattr(,\"class\")\n[1] \"url\"\n\nSe você reproduzir esse processo no RStudio, verá que a url_parseada é uma lista com nove elementos e com a classe “url”. Um dos elementos, query, é também uma lista com quatro elementos (pode ser mais): conversationId, cbPesquisa, dadosConsulta.valorConsulta e cdForo. Exceto o primeiro, conversationId, que está fazio, os demais foram preenchidos por você, ao interagir com a interface do esaj.\nVocê pode alterar a query, por exemplo, para informar o nome de um advogado. Como em toda lista, você usa $ para acessar os elementos em níveis inferiores da lista.\n\n\n\nAgora você pode reconstruir a url a partir da url_parseada com a função build_url:\n\n[1] \"https://esaj.tjsp.jus.br/cpopg/search.do?conversationId=&cbPesquisa=NMADVOGADO&dadosConsulta.valorConsulta=Michel%20Temer&cdForo=-1\"\n\nNote que Fulano de Tal foi efetivamente substituído por Michel Temer e, mais, os espaços foram adequadamente preenchidos por %20, que é uma forma mais segura de realizar a requisição. Experimente copiar esta nova url e colá-la na barra de endereços do seu navegador.\nCabeçalhos\nCabeçalhos ou headers são informações adicionais passadas tanto pelo cliente quanto pelo servidor quando da requisição. Há basicamente três tipos de cabeçalhos: Geral, de requisição e de resposta, dos quais falaremos em seguida. Antes, porém, abra o seu navegador e coloque a url acima ou Clique aqui.\nImagem: consulta advogado por nomeAperte o botão direito do mouse e selecione a opção inspect. Você verá que irá abrir uma nova janela, que é a interface do desenvolvedor. Em seguida, dê Ctrl+Shift+R (control, shift, R) ou Cmd+Shift+R no Mac. Isso fará que a mesma página seja recarregada. Dentro dessa nova janela, você verá várias abas. Uma delas chama-se Network ou Rede, clique nela. Dentro da aba Network ou Rede, clique em Headers. Se tudo ocorreu bem, você verá algo mais ou menos assim, a depender do seu navegador:\nInspetorIsso que você vê são os headers, dos quais falaremos em seguida. Tente familiarizar-se com eles, pois serão de extrema relevância para uma requisição http bem sucedida.\nCabeçalho geral\nO cabeçalho geral contêm informações do status da requisição, a versão http e o tamanho do arquivo transmitido.\nStatus\nA informação mais importante quando você realiza uma requisição http é saber o status, pois ele informa a condição do processamento da requisição. Há seis grupos de status, cada um deles inicia um número de 1 a 6 e é formado por três dígitos. Abaixo um resumo dos principais status:\nInformal, 100 a 102: indica que o servidor não está processando bem a informação.\nSucesso, 200 a 208 e 226: indica que a processamento ocorreu bem e o servidor transmitiu os dados solicitados.\nRedirecionamento, 300 a 308: indica que houve um redirecionamento para outra url ou local.\nErro do cliente, 400 a 499: com vários saltos: indica erro de requisição por parte do cliente, e.g., a url não existe, pedido não autorizado etc.\nErro do servidor, 500 a 511 e 599: indica erro do servidor,e.g., serviço indisponível, erro interno etc.\nTamanho\nO tamanho é também mostrado. Se o status for 200, saber o tamanho é importante pois informa quanto tempo pode demorar para finalizar a transmissão e o quanto de memória você tem de reservar para receber esse dado.\nCabeçalhos de requisição\nSe você rolar a aba headers até o final, verá uma série de pares chave: valor. Esse são os cabeçalhos de requisição. Eles são informações adicionais acerca de quem está realizando a requisição, bem como, o que este espera receber ou mesmo, informações retransmitidas, como os cookies. As mais importantes são accept, content-type, cookies e user-agent.\nAccept\nEsse cabeçalho informa ao servidor qual tipo de média o cliente entende. O tipo de media também é conhecido como MIME(Multipurpose Internet Mail Extensions).\nO mais comum é text/html, mas pode ser json, xml, pdf etc.\nContent-type\nEsse cabeçalho existe tanto na requisição quanto na resposta. Na requisição server para informar ao servidor qual o tipo conteúdo está sendo enviado no corpo. Falaremos do corpo mais adiante.\nCookies\nOs cookies são peças de informação enviadas pelo servidor e armazenadas no navegador do cliente. Falamos disso no tutorial introdutório. Por vezes, você precisará pegar o cookie de uma requisição anterior e informá-lo na posterior.\nUser-agent\nO user-agent informa ao servidor qual aplicação com sua respectiva versão está realizando a requisição. Por exemplo, pode ser o Chrome, o Firefox, Safari etc. Nas requisições com o httr, a aplicação é um programa chamado curl/versão. O curl é o programa escrito em linguagem C, que roda por trás do httr.\nAlguns servidores são restritivos em relação ao user-agent. Por vezes, temos de informar que o user-agent é o mesmo do navegador que estamos usando para inspecionar a página. Por exemplo, eu copiei o user-agent do meu navegador e veio essa informação: “Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/112.0”.\nCabeçalhos de resposta\nOs cabeçalhos de resposta contêm informações prestadas pelo servidor. O mais importante deles é o content-type, porque ele diz qual o tipo de arquivo estamos importando. Pode ser text/html, application/json, application/pdf etc.\nCorpo\nO terceiro elemento da requisição é o corpo. Este, porém, só entra no método POST. O corpo é basicamente o um formulário que você preenche para fornecer informações de filtro para a consulta e/ou outras informações a seu respeito que autorizem acessar aquela informação ou mesmo informações de requisição anterior.\nExercícios práticos\nVamos aplicar o que aprendemos até aqui realizando requisições a alguns tribunais.\nJulgados de primeiro grau do TJSP\nO primeiro passo para realizar uma requisição é interagir com a página e observar como ela opera para retornar os resultados. Passo a passo:\nAbra a página de busca de julgados de primeiro grau do TJSP aqui.\nRealize uma busca livre, e.g., consulte por “danos morais”.\nClique com o botão direito do mouse, opte por inspecionar. - Recarregue a página com Ctrl+Shift+R. - Clique na aba Network ou Rede.\nVerifique o método. No caso, o método é o GET. - Copie que aparece acima. Veja que ela tem uma longa query.\nFeito isso, estamos prontos para realizar nossa primeira requisição. O pacote httr contêm uma função chamada GET que fará a requisição por nós. Eu colei a url abaixo, mas creio que ela é muito longa para ser visualizada numa página.\n\n\n\nAgora vamos parsear essa url e imprimi-la:\n\n$scheme\n[1] \"https\"\n\n$hostname\n[1] \"esaj.tjsp.jus.br\"\n\n$port\nNULL\n\n$path\n[1] \"cjpg/pesquisar.do\"\n\n$query\n$query$conversationId\n[1] \"\"\n\n$query$dadosConsulta.pesquisaLivre\n[1] \"danos morais\"\n\n$query$tipoNumero\n[1] \"UNIFICADO\"\n\n$query$numeroDigitoAnoUnificado\n[1] \"\"\n\n$query$foroNumeroUnificado\n[1] \"\"\n\n$query$dadosConsulta.nuProcesso\n[1] \"\"\n\n$query$dadosConsulta.nuProcessoAntigo\n[1] \"\"\n\n$query$classeTreeSelection.values\n[1] \"\"\n\n$query$classeTreeSelection.text\n[1] \"\"\n\n$query$assuntoTreeSelection.values\n[1] \"\"\n\n$query$assuntoTreeSelection.text\n[1] \"\"\n\n$query$agenteSelectedEntitiesList\n[1] \"\"\n\n$query$contadoragente\n[1] \"0\"\n\n$query$contadorMaioragente\n[1] \"0\"\n\n$query$cdAgente\n[1] \"\"\n\n$query$nmAgente\n[1] \"\"\n\n$query$dadosConsulta.dtInicio\n[1] \"\"\n\n$query$dadosConsulta.dtFim\n[1] \"25/03/2023\"\n\n$query$varasTreeSelection.values\n[1] \"\"\n\n$query$varasTreeSelection.text\n[1] \"\"\n\n$query$dadosConsulta.ordenacao\n[1] \"DESC\"\n\n\n$params\nNULL\n\n$fragment\nNULL\n\n$username\nNULL\n\n$password\nNULL\n\nattr(,\"class\")\n[1] \"url\"\n\nExamine a url_parseada e note que a busca por danos morais está dentro do elemento \\(query\\)dadosConsulta.pesquisaLivre. Vamos alterá-lo para danos materiais e reconstruir a url:\n\n\n\nCom isso, basta reconstruir a url:\n\n\n\nAgora podemos realizar a requisição:\n\n\n\nVisualize o cabeçalho geral da resposta:\n\nResponse [https://esaj.tjsp.jus.br/cjpg/pesquisar.do?conversationId=&dadosConsulta.pesquisaLivre=danos%20materiais&tipoNumero=UNIFICADO&numeroDigitoAnoUnificado=&foroNumeroUnificado=&dadosConsulta.nuProcesso=&dadosConsulta.nuProcessoAntigo=&classeTreeSelection.values=&classeTreeSelection.text=&assuntoTreeSelection.values=&assuntoTreeSelection.text=&agenteSelectedEntitiesList=&contadoragente=0&contadorMaioragente=0&cdAgente=&nmAgente=&dadosConsulta.dtInicio=&dadosConsulta.dtFim=25%2F03%2F2023&varasTreeSelection.values=&varasTreeSelection.text=&dadosConsulta.ordenacao=DESC]\n  Date: 2023-04-26 10:23\n  Status: 200\n  Content-Type: text/html;charset=UTF-8\n  Size: 242 kB\n\n\n\n\n\n\n\n\n\n\n...\n\nNote que o status é 200 (ok ou sucesso). O tamanho pode variar a depender do momento da pesquisa.\nVamos agora realizar a mesma requisição e salvá-la em disco. Para tanto, usamos, dentro da função GET uma outra função chamada write_disk. A diferença é que agora, não precisamos criar um objeto no R, somente um arquivo no disco.\nGET(url, write_disk(\"nome_do_arquivo.html\"))\nAbra o arquivo e veja como ficou o resultado.\n\n\n\n",
    "preview": {},
    "last_modified": "2023-04-26T07:23:14-03:00",
    "input_file": "raspagem-de-tribunais-requisio-http.knit.md"
  },
  {
    "path": "posts/2022-12-26-json-no-rparte1/",
    "title": "Json no R - Parte 1",
    "description": "Este é o primeiro tutorial de dois sobre JSON no R. Nesta primeira parte, mostro como usar o pacote `jsonlite` para converter de JSON para R e vice-versa. Na [segunda parte](https://direitoemdados.consudata.com.br/posts/2022-12-26-json-no-rparte2/), trato de como trabalhar com JSON como JSON mesmo no R, sem convertê-lo para lista ou dataframe.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://github.com/jjesusfilho"
      }
    ],
    "date": "2022-12-26",
    "categories": [],
    "contents": "\nUm dos formatos de arquivos que eu mais gosto de trabalhar é JSON (JavaScript Object Notation). A graça de JSON é ser um formato amigável para seres humanos e para máquinas. Coloco abaixo o exemplo de parte de um currículo.\n{\n    \"id\": 2,\n    \"data\": \"2022-01-01\",\n    \"nome\": {\n        \"primeiro_nome\": \"José\",\n        \"sobrenome\": \"de Jesus Filho\"\n    },\n    \"cpf\": \"123.456.789-34\",\n    \"disponivel\": true,\n    \"educacao\": [\n        {\n            \"escola\": \"EMPG Milton Campos\",\n            \"ensino\": \"Fundamental\",\n            \"inicio\": 1982,\n            \"fim\": 1989\n        },\n        {\n            \"escola\": \"Derville Allegretti\",\n            \"ensino\": \"medio\",\n            \"inicio\": 1990,\n            \"fim\": 1992\n        }\n    ],\n    \"experiencia_profissional\": [\n        {\n            \"empresa\": \"Companhia Brasileria de Distribuição\",\n            \"cargo\": \"empacotador\",\n            \"inicio\": 1986,\n            \"fim\": 1988\n        },\n        {\n            \"empresa\": \"Compneus\",\n            \"cargo\": \"gerente\",\n            \"inicio\": 1990,\n            \"fim\": 1992\n        },\n        {\n            \"empresa\": \"Varias\",\n            \"cargo\": \"muitos\",\n            \"inicio\": 1992,\n            \"fim\": 2021\n        },\n        {\n            \"empresa\": \"MPSP\",\n            \"cargo\": \"Jurimetrista\",\n            \"inicio\": 2022,\n            \"fim\": null\n        }\n    ]\n}\nDiferentemente de XML, JSON é simples e fácil de manipular. No entanto, essa simplicidade vem com um custo. JSON carece de namespace, o que facilmente pode gerar conflitos e perda de integridade dos dados. Se você quer entender para que serve namespace, carregue o pacote dplyr e busque a ajuda para a função filter, você notará que há duas funções distintas com o mesmo nome, porém uma no namespace dplyr e outra no stats. Pacotes são namespaces, schemas em SQL são namespaces e XML também usa namespaces. Namespaces asseguram unicidade nos nomes dos objetos.\nAdemais, JSON só reconhece quatro (4) tipos/classes de dados (texto, número, boleano e nulo). Datas e dados categóricos (fatores ou enum) não são reconhecidos. Além disso, JSON têm duas estruturas universais:\nJSON objeto: Uma coleção desordenada de pares chave/valor. Esses valores podem ser aqueles acima mencionados: texto (string), número (number), boleano (boolean) e nulo, bem como os próprios objetos JSON e arrays.\nJSON array: Uma coleção ordenada de valores.\nNote acima que o JSON está dentro de chaves {…}, indicando que se trata de um objeto JSON. Nele há vários objetos: id, data, nome, cpf, disponivel, educacao e experiencia_profissional. O id é numérico, data, nome e cpf são textos e disponível é lógico (boleano). Por sua vez, educacao e experiencia_profissional são arrays. Arrays estão sempre entre colchetes.\nPerceba também que as chaves ou nomes (keys) estão sempre entre aspas e os valores, quando textos também entre aspas, números, boleanos e nulos (último ítem “fim” da experiência profissional), sem aspas.\nO exemplo acima é simples e fácil de entender, mas JSON pode ser complexo, com profundos aninhamentos de objetos e arrays, o que torna a conversão de um JSON para um objeto nativo do R e vice-versa um desafio e sujeita a erros de toda sorte.\nNeste tutorial, mostraremos como trabalhar como pacote jsonlite, o qual converte JSON em objetos do R e vice-versa. No próximo, falaremos do pacote jqr, o qual manuseia JSON como JSON mesmo, sem convertê-lo para lista ou data.frame.\nO pacote jsonlite\nO pacote jsonlite permite ler, escrever e validar JSONs. Vamos tratar do exemplo acima:\n\n\nx <- '{\n    \"id\": 2,\n    \"data\": \"2022-01-01\",\n    \"nome\": {\n        \"primeiro_nome\": \"José\",\n        \"sobrenome\": \"de Jesus Filho\"\n    },\n    \"cpf\": \"123.456.789-34\",\n    \"disponivel\": true,\n    \"educacao\": [\n        {\n            \"escola\": \"EMPG Milton Campos\",\n            \"ensino\": \"Fundamental\",\n            \"inicio\": 1982,\n            \"fim\": 1989\n        },\n        {\n            \"escola\": \"Derville Allegretti\",\n            \"ensino\": \"medio\",\n            \"inicio\": 1990,\n            \"fim\": 1992\n        }\n    ],\n    \"experiencia_profissional\": [\n        {\n            \"empresa\": \"Companhia Brasileria de Distribuição\",\n            \"cargo\": \"empacotador\",\n            \"inicio\": 1986,\n            \"fim\": 1988\n        },\n        {\n            \"empresa\": \"Compneus\",\n            \"cargo\": \"gerente\",\n            \"inicio\": 1990,\n            \"fim\": 1992\n        },\n        {\n            \"empresa\": \"Varias\",\n            \"cargo\": \"muitos\",\n            \"inicio\": 1992,\n            \"fim\": 2021\n        },\n        {\n            \"empresa\": \"MPSP\",\n            \"cargo\": \"Jurimetrista\",\n            \"inicio\": 2022,\n            \"fim\": null\n        }\n    ]\n}'\n\n\no pacote jsonlite possui um função para converter JSON para objeto do R chamada fromJSON:\n\n\nlibrary(jsonlite)\nobj <- fromJSON(x)\n\nobj\n\n$id\n[1] 2\n\n$data\n[1] \"2022-01-01\"\n\n$nome\n$nome$primeiro_nome\n[1] \"José\"\n\n$nome$sobrenome\n[1] \"de Jesus Filho\"\n\n\n$cpf\n[1] \"123.456.789-34\"\n\n$disponivel\n[1] TRUE\n\n$educacao\n               escola      ensino inicio  fim\n1  EMPG Milton Campos Fundamental   1982 1989\n2 Derville Allegretti       medio   1990 1992\n\n$experiencia_profissional\n                               empresa        cargo inicio  fim\n1 Companhia Brasileria de Distribuição  empacotador   1986 1988\n2                             Compneus      gerente   1990 1992\n3                               Varias       muitos   1992 2021\n4                                 MPSP Jurimetrista   2022   NA\n\nA vantagem do jsonlite é que ele opera um excelente mapeamento entre JSON e objetos do R. O JSON foi convertido numa lista de sete elementos, dos quais alguns vetores de um único elemento, nome é uma lista, e educacao e experiencia_profissional são dataframes. Além disso, os textos foram convertidos para characters, números tornaram-se integers, true foi propriamente convertido para TRUE e null para NA.\nA data foi mantida como character porque JSON não tem especificação para datas.\nO pacote jsonlite possibilita o caminho reverso por meio da função toJSON:\n\n\ntoJSON(obj)\n\n{“id”:[2],“data”:[“2022-01-01”],“nome”:{“primeiro_nome”:[“José”],“sobrenome”:[“de Jesus Filho”]},“cpf”:[“123.456.789-34”],“disponivel”:[true],“educacao”:[{“escola”:“EMPG Milton Campos”,“ensino”:“Fundamental”,“inicio”:1982,“fim”:1989},{“escola”:“Derville Allegretti”,“ensino”:“medio”,“inicio”:1990,“fim”:1992}],“experiencia_profissional”:[{“empresa”:“Companhia Brasileria de Distribuição”,“cargo”:“empacotador”,“inicio”:1986,“fim”:1988},{“empresa”:“Compneus”,“cargo”:“gerente”,“inicio”:1990,“fim”:1992},{“empresa”:“Varias”,“cargo”:“muitos”,“inicio”:1992,“fim”:2021},{“empresa”:“MPSP”,“cargo”:“Jurimetrista”,“inicio”:2022}]}\n\nA primeira observação é que JSON não está nada elegante nem formatado para facilitar a leitura humana. Igualmente, percebe-se que os vetores de um único elemento foram todos convertidos em arrays. Por fim, a chave-valor fim do último cargo, que era NA no R simplesmente desapareceu.\nA função toJSON possui argumentos para reverter isso.\n\n\ntoJSON(obj, \n      pretty = T, ## Tornar amigável ao usuário\n      na = \"null\", ## converte NA para nulo\n      auto_unbox = TRUE) ## retira os colchetes dos elementos únicos.\n\n{\n  \"id\": 2,\n  \"data\": \"2022-01-01\",\n  \"nome\": {\n    \"primeiro_nome\": \"José\",\n    \"sobrenome\": \"de Jesus Filho\"\n  },\n  \"cpf\": \"123.456.789-34\",\n  \"disponivel\": true,\n  \"educacao\": [\n    {\n      \"escola\": \"EMPG Milton Campos\",\n      \"ensino\": \"Fundamental\",\n      \"inicio\": 1982,\n      \"fim\": 1989\n    },\n    {\n      \"escola\": \"Derville Allegretti\",\n      \"ensino\": \"medio\",\n      \"inicio\": 1990,\n      \"fim\": 1992\n    }\n  ],\n  \"experiencia_profissional\": [\n    {\n      \"empresa\": \"Companhia Brasileria de Distribuição\",\n      \"cargo\": \"empacotador\",\n      \"inicio\": 1986,\n      \"fim\": 1988\n    },\n    {\n      \"empresa\": \"Compneus\",\n      \"cargo\": \"gerente\",\n      \"inicio\": 1990,\n      \"fim\": 1992\n    },\n    {\n      \"empresa\": \"Varias\",\n      \"cargo\": \"muitos\",\n      \"inicio\": 1992,\n      \"fim\": 2021\n    },\n    {\n      \"empresa\": \"MPSP\",\n      \"cargo\": \"Jurimetrista\",\n      \"inicio\": 2022,\n      \"fim\": null\n    }\n  ]\n} \n\nSe você quiser salvar um objeto do R como JSON, use a função write_JSON com os mesmos argumentos da toJSON adicionados do argumento path:\nwrite_JSON(obj,\n          path = \"curriculo.JSON\",\n          pretty = TRUE,\n          na = \"JSON\",\n          auto_unbox = TRUE)\nPreservando atributos de objetos R\nPor vezes, você quer converter um objeto R para JSON e revertê-lo posteriormente para R. A título de exemplo, vamos criar simples tibble e convertê-la para JSON.\n\n\ndf <- tibble::tibble(a = 1:5, b = letters[1:5])\n\nJSON <- toJSON(df, pretty = TRUE)\n\nJSON\n\n[\n  {\n    \"a\": 1,\n    \"b\": \"a\"\n  },\n  {\n    \"a\": 2,\n    \"b\": \"b\"\n  },\n  {\n    \"a\": 3,\n    \"b\": \"c\"\n  },\n  {\n    \"a\": 4,\n    \"b\": \"d\"\n  },\n  {\n    \"a\": 5,\n    \"b\": \"e\"\n  }\n] \n\nSe quisermos nossa tibble de volta, o resultado pode ser frustrante:\n\n\ntb <- fromJSON(JSON)\n\nclass(tb)\n\n[1] \"data.frame\"\n\nO pacote jsonlite oferece duas alternativas a toJSON e fromJSON, as quais preservam os atributos originais:\n\n\nsJSON <- serializeJSON(df, pretty = T)\nsJSON\n\n{\n  \"type\": \"list\",\n  \"attributes\": {\n    \"class\": {\n      \"type\": \"character\",\n      \"attributes\": {},\n      \"value\": [\"tbl_df\", \"tbl\", \"data.frame\"]\n    },\n    \"row.names\": {\n      \"type\": \"integer\",\n      \"attributes\": {},\n      \"value\": [1, 2, 3, 4, 5]\n    },\n    \"names\": {\n      \"type\": \"character\",\n      \"attributes\": {},\n      \"value\": [\"a\", \"b\"]\n    }\n  },\n  \"value\": [\n    {\n      \"type\": \"integer\",\n      \"attributes\": {},\n      \"value\": [1, 2, 3, 4, 5]\n    },\n    {\n      \"type\": \"character\",\n      \"attributes\": {},\n      \"value\": [\"a\", \"b\", \"c\", \"d\", \"e\"]\n    }\n  ]\n} \n\nO JSON resultante é mais verboso, mas assegura o retorno ao objeto R original:\n\n\nutb <- unserializeJSON(sJSON)\nclass(utb)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\nSe quisermos imprimir a tibble:\n\n\nutb\n\n# A tibble: 5 × 2\n      a b    \n* <int> <chr>\n1     1 a    \n2     2 b    \n3     3 c    \n4     4 d    \n5     5 e    \n\nHá outros recursos no pacote, como imprimir objetos json de forma bonita (prettify), mas creio que o essencial foi falado. Não se esqueça de ler o tutorial 2, nele mostramos uma infinidade de recursos para trabalhar com JSON.\n\n\n\n",
    "preview": {},
    "last_modified": "2022-12-26T12:43:25-03:00",
    "input_file": "json-no-rparte1.knit.md"
  },
  {
    "path": "posts/2022-12-26-json-no-rparte2/",
    "title": "Json no R - Parte 2",
    "description": "Este é o segundo tutorial sobre JSON no R. Na [primeira parte](https://direitoemdados.consudata.com.br/posts/2022-12-26-json-no-rparte1/), trabalhamos com o pacote `jsonlite`, que converte json para R. Neste, trabalhamos com o pacote `jqr`, o qual manuseia o json por ele mesmo.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://github.com/jjesusfilho"
      }
    ],
    "date": "2022-12-26",
    "categories": [],
    "contents": "\nPacote jqr\nDiferentemente do jsonlite, o jqr opera com JSON como JSON mesmo. Ele é uma implementação da biblioteca jq: (http://stedolan.github.io/jq/) no R. Há duas interfaces, uma de baixo nível, que emula o jq via linha de comando, ou de alto nível que adota funções do R. Primeiramente, mostraremos como o baixo nível porque ele é rico em recursos e uma vez que o conhece, você pode usá-lo inclusive na linha de comando.\nInstalação\nPara instalar os binários no Mac e no Windows, basta chamar:\ninstall.packages(\"jqr\")\nNo Linux, você tem de instalar o biblioteca a libjq-dev antes.\nBaixo nível\nNo baixo nível, você tem apenas de chamar a função jq e colocar entre aspas aquilo que você escreveria se estivesse usando jq no terminal. A biblioteca jq tem um playground para você testar: (https://jqplay.org/).\nVamos retomar currículo criado no primeiro tutorial:\n\n\nx <- '{\n    \"id\": 2,\n    \"data\": \"2022-01-01\",\n    \"nome\": {\n        \"primeiro_nome\": \"José\",\n        \"sobrenome\": \"de Jesus Filho\"\n    },\n    \"cpf\": \"123.456.789-34\",\n    \"disponivel\": true,\n    \"educacao\": [\n        {\n            \"escola\": \"EMPG Milton Campos\",\n            \"ensino\": \"Fundamental\",\n            \"inicio\": 1982,\n            \"fim\": 1989\n        },\n        {\n            \"escola\": \"Derville Allegretti\",\n            \"ensino\": \"medio\",\n            \"inicio\": 1990,\n            \"fim\": 1992\n        }\n    ],\n    \"experiencia_profissional\": [\n        {\n            \"empresa\": \"Companhia Brasileria de Distribuição\",\n            \"cargo\": \"empacotador\",\n            \"inicio\": 1986,\n            \"fim\": 1988\n        },\n        {\n            \"empresa\": \"Compneus\",\n            \"cargo\": \"gerente\",\n            \"inicio\": 1990,\n            \"fim\": 1992\n        },\n        {\n            \"empresa\": \"Varias\",\n            \"cargo\": \"muitos\",\n            \"inicio\": 1992,\n            \"fim\": 2021\n        },\n        {\n            \"empresa\": \"MPSP\",\n            \"cargo\": \"Jurimetrista\",\n            \"inicio\": 2022,\n            \"fim\": null\n        }\n    ]\n}'\n\n\nExtração\nSuponha que você queira extrair do currículo acima o cpf. Basta chamar a função jq() e colocar dentro de aspas o elemento precedido por ponto.\n\n\nlibrary(jqr)\n\nx |> \n  jq(\".cpf\")\n\n\"123.456.789-34\"\n\nVocê pode usar essa mesma sintaxe para obter subelementos.\n\n\nx |> \n  jq(\".nome.sobrenome\")\n\n\"de Jesus Filho\"\n\nSe quiser obter o primeiro elemento do array educacao, use colchetes:\n\n\nx |> \n  jq(\".educacao[0]\")\n\n{\n    \"escola\": \"EMPG Milton Campos\",\n    \"ensino\": \"Fundamental\",\n    \"inicio\": 1982,\n    \"fim\": 1989\n}\n\nNote que JSON começa a contar do zero.\nSe quiser a escola do segundo elemento de educacao:\n\n\nx |> \n  jq(\".educacao[1].escola\")\n\n\"Derville Allegretti\"\n\nCom pipe do R:\n\n\nx |> \n   jq(\".nome\") |> \n   jq(\".primeiro_nome\")\n\n\"José\"\n\ncom pipe do qr:\n\n\nx |> \n   jq(\".nome|.primeiro_nome\")\n\n\"José\"\n\nObjeto faltante\nE se você quiser algo que não existe:\n\n\nx |> \n  jq(\".idade\")\n\nnull\n\nA sintaxe acima funciona bem quando a chave (key) é simples, começa com uma letra e contêm somente dígitos e sublinhado. Isso aqui não funciona:\n\n\n'{\"1a\": 4, \"&b\": 6}' |> \n  jq('.1a')\n\nError: jq: error: syntax error, unexpected IDENT, expecting $end (Unix shell quoting issues?) at <top-level>, line 1:\n.1a  \n\nMas se você colocar a chave entre colchetes, funciona porque esta é a forma segura:\n\n\n'{\"1a\": 4, \"&b\": 6}' |> \n  jq('.[\"1a\"]')\n\n4\n\nVírgula\nSe você separar os filtros por vírgula, ele roda cada um deles e retorna um array:\n\n\n'{\"primeiro_nome\": \"José\",\"sobrenome\": \"de Jesus Filho\"}' |> \n  jq('.primeiro_nome, .sobrenome')\n\n[\n    \"José\",\n    \"de Jesus Filho\"\n]\n\nFatiamento\nSe o seu JSON é um array, você pode fatiá-lo. No entanto, ele começa a contar do zero e, assim como em Python, o último índice não entra. Isso pode parecer estranho para usuários de R, mas com o tempo você se acostuma.\n\n\n'[\"a\", \"b\", \"c\", \"d\", \"e\"]' |> \n  jq(\".[2:4]\")\n\n[\n    \"c\",\n    \"d\"\n]\n\nVários valores com getpath:\n\n\nx |> \n  jq('getpath([\"nome\", \"primeiro_nome\"], [\"nome\",\"sobrenome\"])')\n\n[\n    \"José\",\n    \"de Jesus Filho\"\n]\n\nSubstituição\nSubstituição é tão simples quanto. Vamo substituir “José” por “João” no primeiro_nome:\n\n\n'{\"primeiro_nome\": \"José\",\"sobrenome\": \"de Jesus Filho\"}' |> \n  jq('.primeiro_nome = \"João\"')\n\n{\n    \"primeiro_nome\": \"João\",\n    \"sobrenome\": \"de Jesus Filho\"\n}\n\nRepare que precisei colocar tudo entre aspas simples porque primeiro_nome é texto e, por isso, precisei usar aspas duplas em “João”.\nRemoção de valores\nA função del remove uma chave e seu correspondente valor:\n\n\n'{\"primeiro_nome\": \"José\",\"sobrenome\": \"de Jesus Filho\"}' |> \n  jq(\"del(.primeiro_nome)\")\n\n{\n    \"sobrenome\": \"de Jesus Filho\"\n}\n\nOperadores\nVocê pode usar operadores para somar números:\n\n\n'{\"a\": 3, \"b\": 5}' |> \njq(\".a + 3\")\n\n6\n\n\n\n'{\"a\": 3, \"b\": 5}' |> \njq(\".a * .b\")\n\n15\n\nPorém, quando se trata de texto:\n\n\n'{\"a\": \"arroz \", \"b\": \"e \", \"c\": \"feijão\"}' |> \n  jq(\".a + .b + .c\")\n\n\"arroz e feijão\"\n\nSomente as chaves\nChaves na ordem em que aparecem:\n\n\nx |> \n  jq(\". | keys_unsorted\")\n\n[\n    \"id\",\n    \"data\",\n    \"nome\",\n    \"cpf\",\n    \"disponivel\",\n    \"educacao\",\n    \"experiencia_profissional\"\n]\n\nChaves ordenadas alfabeticamente:\n\n\nx |> \n  jq(\". | keys\")\n\n[\n    \"cpf\",\n    \"data\",\n    \"disponivel\",\n    \"educacao\",\n    \"experiencia_profissional\",\n    \"id\",\n    \"nome\"\n]\n\nA chave existe?\n\n\nx |> \n   jq('has(\"nome\")')\n\ntrue\n\nOperadores map e map_values\nVocê usa map para operar em cada elemento e uma array:\n\n\n'[2,6,8]' |> \n  jq(\"map(. + 1)\")\n\n[\n    3,\n    7,\n    9\n]\n\nUsa map_values para objetos:\n\n\n'{\"a\": 2, \"b\": 3, \"c\": 4}' |> \n   jq(\"map_values(. *4)\")\n\n{\n    \"a\": 8,\n    \"b\": 12,\n    \"c\": 16\n}\n\nExpressões regulares\nSe você sabe expressões regulares, pode usar, mas ao usar “\\”, você tem de dar escape duas vezes:\nDetecta\nVerifica se no cpf há números:\n\n\nx |> \n  jq('.cpf | test(\"\\\\\\\\d\")')\n\ntrue\n\nOu prefira raw strings:\n\n\narg <- r\"(.experiencia_profissional[].empresa | test(\"(?i)com\\\\w+\"))\"\n\nx |> \n   jq(arg)\n\n[\n    true,\n    true,\n    false,\n    false\n]\n\nVocê pode usar flags:\ng - Pesquisa global (encontrar todas as correspondências, não apenas a primeira)\ni - Não diferencia maiúsculas de minúsculas\nm - Modo de várias linhas ('.' ignora quebra de linhas)\nn - Ignora correspondências vazias\np - Ambos os modos s e m estão ativados\ns - Modo de linha única ('^' -> '\\A', '$' -> '\\Z')\nl - Encontre correspondências mais longas possíveis\nx - Formato regex estendido (ignora espaços em branco e comentários)\n\n\nx |> \n  jq('.nome.primeiro_nome | test(\"josé\"; \"i\")')\n\ntrue\n\nCaptura\nVocê pode extrair texto com base em regex usando capture, mas você tem de informar a nova chave (key). Veja na sintaxe que eu começo com interrogação seguido da nova chave dentro de <…>:\n\n\n'{\"cep\": [\"05077-902\", \"02598154\"]}' |> \n   jq('.cep[] | capture(\"(?<codigo_postal>[0-9]+-?[0-9]+)\")')\n\n[\n    {\n        \"codigo_postal\": \"05077-902\"\n    },\n    {\n        \"codigo_postal\": \"02598154\"\n    }\n]\n\nMatch\nOutra função é match, que retorna um objeto json com quatro campos:\noffset: posição inicial do padrão\nlength: tamanho do padrão\nstring: o padrão encontrado\ncaptures: array de objectos com os grupos de captura. Estes, por sua vez, com os seguintes campos: offset, length, string, name. Abaixo não aparecem porque não usamos grupos de captura.\nVejamos:\n\n\narg <- r\"(.educacao[].escola | match(\"\\\\w+ll\\\\w*\"; \"g\"))\"\n\nx |> \n   jq(arg)\n\n[\n    {\n        \"offset\": 0,\n        \"length\": 8,\n        \"string\": \"Derville\",\n        \"captures\": [\n\n        ]\n    },\n    {\n        \"offset\": 9,\n        \"length\": 10,\n        \"string\": \"Allegretti\",\n        \"captures\": [\n\n        ]\n    }\n]\n\nSe quiser preservar somente o padrão:\n\n\narg <- r\"(.educacao[].escola | match(\"\\\\w+ll\\\\w*\"; \"g\") | .string)\"\n\nx |> \n   jq(arg)\n\n[\n    \"Derville\",\n    \"Allegretti\"\n]\n\nEste tutorial apenas tocou no pacote jqr. Há uma uma multiplicidade de funções e recursos avançados os quais podem ser explorados sem sair do R. Aproveite para ler o manul: (https://stedolan.github.io/jq/manual)\n\n\n\n",
    "preview": {},
    "last_modified": "2022-12-26T17:48:36-03:00",
    "input_file": "json-no-rparte2.knit.md"
  },
  {
    "path": "posts/2022-10-15-objetos/",
    "title": "Objetos no R",
    "description": "Neste tutorial, mostramos o que são objetos no R e como\nmanuseá-los.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://github.com/jjesusfilho"
      }
    ],
    "date": "2022-10-15",
    "categories": [],
    "contents": "\nObjetos no R\nObjetos são valores nomeados. Quando falamos de valores no R, estamos\nnos referindo a algo que ocupa espaço na memória ram do cumputador. Pode\nser um número, um texto ou um conjunto de números ou de textos.\nEsses valores podem ser submetidos a operações matemáticas, no caso\nde números, ou transformados para gerar outros valores. Por exemplo,\n“Maria” pode se transformar em “MARIA”.\nCriando objetos\nPara criar objetos no R, você deve atribuir um valor a um nome.\nExemplos:\n\n\nnumero <- 2\n\nnome <- \"Maria\"\nnumero\n\n[1] 2\n\nnome\n\n[1] \"Maria\"\n\nPerceba que usamos o operador <- para atribuir o\nvalor a um nome. No R, você sempre usa esse operador para atribuir. Há\num outro operador, o =, que também pode ser usado, mas este\npossui usos mais específicos e falaremos dele no momento oportuno.\nDar nomes a objetos é como dar nome a filhos, alguns são proibidos,\noutros podem causar muitos problemas no futuro. Se você quiser chamar\nseu filho de “Esfiha”, o cartório irá recusar o registro. Se você usar\ncertos nomes, o R retornará um erro. Veja os exemplos abaixo, nomes têm\nde começar com letra e não podem ter operadores.\n3 <- 2 \n4m <- 4\n_x <- 'Mário' \nbem-te-vi <- \"pássaro\" ## O hífen é um operador matemático.\nEm todos os casos acima, o R recusará a criação do objeto. Assim\nmesmo, caso queira insistir na nomeação não convencional, o R aceitará\nse você usar o acento grave como demarcador:\n\n\n`3` <- 2 \n`3`\n\n[1] 2\n\nSe você fizer isso, as chances de encontrar problemas no futuro são\naltas.\nÉ aconselhável usar nomes sugestivos dos valores contidos neles, em\nletra minúscula e separados por _.\n\n\nidade <- c(25,29,40,57)\nendereco_residencial <- \"Rua José Mario Pereira, 43\"\n\n\nVetores\nQuando concatenamos um conjunto de valores da mesma natureza,\nchamamos esse objeto de vetor atômico. Exemplos:\n\n\nnumeros <- c(2,5,9,20)\nnumeros \n\n[1]  2  5  9 20\n\nnomes <- c(\"Maria\", \"Flávia\",\"Roberto\", \"Pedro\")\nnomes\n\n[1] \"Maria\"   \"Flávia\"  \"Roberto\" \"Pedro\"  \n\nObserve que para criar esses objetos, colocamos eles dentro da letra\nc com parênteses, que significa concatenar valores.\nOs vetores atômicos são assim chamados porque só podem conter um tipo\nde valor. Se você tentar concatenar texto com número, este último será\nconvertido em texto e você perderá a capacidade de realizar operações\nmatemáticas com ele.\n\n\nx <- c(\"Mário\", 3)\nx\n\n[1] \"Mário\" \"3\"    \n\nTipos e classes de objetos\nOs objetos podem ter tipos e classes. Os tipos correspondem à\nnatureza mesma do objeto, as classes dizem respeito ao\ncomportamento.\nInteiros\nVocê define um inteiro no R, colocando um L depois do número:\n\n\ninteiro <- 4L\ntypeof(inteiro)\n\n[1] \"integer\"\n\nNote que usamos a função typeof() para saber qual a\nnatureza do objeto.\nDouble\nDouble ou precisão dupla são formatos numéricos que ocupam 64 bits da\nmemória do computador, em contraste precisão singular, que ocupam 32.\nSão usados para referir a números com casas decimais, tanto racionais\nquanto irracionais.\n\n\nx <- 2.3\ny <- pi\n\ntypeof(x)\n\n[1] \"double\"\n\ntypeof(y)\n\n[1] \"double\"\n\nCharacter\nCharacter é o formato texto, ou string, em outras linguagens. Você\nusa ele para criar valores que não serão usados para operações\nmatématicas. Para criar character, você precisa usar aspas simples ou\nduplas.\n\n\nnome <- \"Flaviana\"\ncpf <- \"123.456.768-10\"\n\n\nSe você colocar aspas nos números, eles serão tratados como\ncharacteres. Se você tentar realizar operações, o R retornará um\nerro.\n\n\nn1 <- \"2\"\nn2 <- \"3\"\n\nn1 + n2\n\nError in n1 + n2: argumento não-numérico para operador binário\n\nMesmos tipos,\ndiferentes comportamentos (classes)\nEm programação, além dos tipos, existe uma outro conceito chamado\nclasse, o qual diz respeito ao comportamento dos objetos. Os tipos\nbásicos que vimos acima, podem ser representados em diferentes classes.\nDuas delas são especialmente importantes: datas e fatores\nDatas\nDatas são do tipo numérico (double), mas visualizadas no seguinte\nformato: “aaaa-mm-dd”, ou seja, mês, dia, ano. Esse formato segue o\npadrão internacional ISO-8601. O ano vem sempre com quatro dígitos e a\nordem segue do maior para o menor.\nPara criar datas, precisamos de uma função do R chamas\nas.Date().\n\n\nd1 <- as.Date(\"2022-02-15\")\nd1\n\n[1] \"2022-02-15\"\n\nVeja que ela foi impressa entre aspas, mas na verdade ela é um\ndouble:\n\n\ntypeof(d1)\n\n[1] \"double\"\n\nIsso ocorre porque, dessa forma, você pode realizar operações\nmatemáticas com datas:\n\n\nd1 <- as.Date(\"2022-02-15\")\nd2 <- as.Date(\"2022-03-16\")\n\nd2 - d1\n\nTime difference of 29 days\n\nComo a data é um número, é possível convertê-la para o formato\ndouble, usando a função as.numeric():\n\n\nas.numeric(d1)\n\n[1] 19038\n\nEsse número, 19038, é o número de dias desde 01 de janeiro de 1970.\nDatas anteriores a esta data são representadas negativamente:\n\n\nn3 <- as.Date(\"1950-04-03\")\nas.numeric(n3)\n\n[1] -7213\n\nFatores\nSuponha que você realize uma pesquisa entre seus colegas de trabalho\ncom perguntas como: Qual o seu primeiro nome e qual a sua religião e\nobtenha as seguintes respostas:\n\n\nprimeiro_nome <- c(\"Fábio\",\"Maria\",\"Maria\",\"José\", \"Catarina\",\"José\")\n\nprimeiro_nome\n\n[1] \"Fábio\"    \"Maria\"    \"Maria\"    \"José\"     \"Catarina\" \"José\"    \n\n\n\nreligiao <- c(\"cristão\",\"espírita\",\"budista\", \"cristão\",\"espírita\", \"cristão\")\nreligiao\n\n[1] \"cristão\"  \"espírita\" \"budista\"  \"cristão\"  \"espírita\" \"cristão\" \n\nParece natural que alguns nomes e algumas religões vão se repetir nas\nrespostas. Quando isso acontece, é preferível pedir ao R para armazenar\nessas respostas como números e associar etiquetas a esses números,\ncorrespondentes às respostas. Esse tipo de dados é chamado de categórico\nporque os possíveis valores que ele assume são conhecidos e\nlimitados.\nExiste uma função no R própria para tratar de dados categóricos.\n\n\nprimeiro_nome <- factor(primeiro_nome)\nprimeiro_nome\n\n[1] Fábio    Maria    Maria    José     Catarina José    \nLevels: Catarina Fábio José Maria\n\n\n\nreligiao <- factor(religiao)\nreligiao\n\n[1] cristão  espírita budista  cristão  espírita cristão \nLevels: budista cristão espírita\n\nAo chamar o função factor(), o R associa cada categoria\na um número e etiqueta cada uma delas com os nomes originais. Essas\netiquetas são atributos chamados níveis (levels). Note que os\nlevels estão em ordem alfabética e são únicos.\nReligião agora é do tipo numérico, mas de classe fator. Sua natureza\né numérica, mas seu comportamento é de categoria. Você visualiza como se\nfosse texto, mas, na verdade, é um número.\nSe você converter o fator para inteiro, ele retorna os números\ncorrespondentes.\n\n\nas.integer(religiao)\n\n[1] 2 3 1 2 3 2\n\nHá duas vantagens em usar fatores. A primeira é que os dados serão\narmazenados como inteiros, o que reduz o uso da memória. A segunda é que\nanálises estatísticas realizam operações com matrizes numéricas.\nMatrizes\nMatrizes são vetores atômicos com duas dimensões. Vamos criar um\nvetor de quinze números sequenciais. No R, você faz isso usando : (dois\npontos) entre o primeiro e o último:\n\n\nx <- 1:15\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n\nAgora vamos converter para uma matriz de duas três colunas e cinco\nlinhas:\n\n\nmatrix(x, nrow = 5) # É suficiente informar o número de linhas\n\n     [,1] [,2] [,3]\n[1,]    1    6   11\n[2,]    2    7   12\n[3,]    3    8   13\n[4,]    4    9   14\n[5,]    5   10   15\n\nVocê pode criar uma matriz de textos também. Vamos criar um vetor com\nas dezesseis primeiras letras do alfabeto. O R já tem um objeto chamado\nletters, vamos simplesmente obter um subconjunto delas. Para tanto,\nusamos colchetes.\n\n\nx <- letters[1:16]\nx\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\"\n\n\n\nmatrix(x, ncol = 4)\n\n     [,1] [,2] [,3] [,4]\n[1,] \"a\"  \"e\"  \"i\"  \"m\" \n[2,] \"b\"  \"f\"  \"j\"  \"n\" \n[3,] \"c\"  \"g\"  \"k\"  \"o\" \n[4,] \"d\"  \"h\"  \"l\"  \"p\" \n\nUma característica das matrizes é que elas são atômicas, i.e, todos\nos elementos têm de ser do mesmo tipo.\nDataframes\nSemelhante às planilhas do excel ou as tabelas de SQL, o R possui\ndataframes, que são nada menos que um emparelhamento de vetores do mesmo\ntamanho.\nPara criar dataframes, você usa a função data.frame().\nVamos criar um dataframe com os nomes e respectivas religiões acima\ncriados.\n\n\ndf <- data.frame(primeir_nome = primeiro_nome,\n                 religiao = religiao)\ndf\n\n  primeir_nome religiao\n1        Fábio  cristão\n2        Maria espírita\n3        Maria  budista\n4         José  cristão\n5     Catarina espírita\n6         José  cristão\n\nHá uma classe especial de dataframe chamada tibble, que é\npraticamente idêntica a dataframe, mas um pouco mais segura para\noperar.\nListas\nPor fim, o R possui um tipo de objeto chamado list.\nListas podem conter todos os demais tipois de objetos. Elas geralmente\nsão usados para conter objetos de diferentes tipos e tamanhos. Podemos\ncriar uma lista com alguns dos objetos já criados.\n\n\nlista <- list(religiao, x, df)\nlista\n\n[[1]]\n[1] cristão  espírita budista  cristão  espírita cristão \nLevels: budista cristão espírita\n\n[[2]]\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\"\n\n[[3]]\n  primeir_nome religiao\n1        Fábio  cristão\n2        Maria espírita\n3        Maria  budista\n4         José  cristão\n5     Catarina espírita\n6         José  cristão\n\nOs dataframes são, a rigor, listas também, em que cada coluna\nconstitui um elemento. Eles são listas com a classe dataframe. Isso\nsignifica que o comportamento dos dataframes será diferente das demais\nlistas. Vamos perguntar ao R qual o tipo e qual a classe do objeto df\nacima criado.\n\n\ntypeof(df)\n\n[1] \"list\"\n\n\n\nclass(df)\n\n[1] \"data.frame\"\n\nIndexação e subconjuntos\nDiferentemente de outras linguagens, como Python, que começam a\ncontar do zero, o R começa a contar os elementos de um vetor ou de uma\nlista, a partir do 1 (um) até o tamanho do vetor.\nPara extrair um elemento de um vetor ou de uma lista, use colchetes\ncom o índice. Por exemplo, se quiser obter a segunda letra do\nalfabeto:\n\n\nletters[2]\n\n[1] \"b\"\n\nPara obter da segunda até a quarta letra:\n\n\nletters[2:4]\n\n[1] \"b\" \"c\" \"d\"\n\nSe você quiser excluir uma delas, use o sinal de menos na frente do\nnúmero:\n\n\nletters[-1]\n\n [1] \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\"\n[17] \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\nPor outro lado, se você quiser obter valores contando do final, use a\nfunção length() dentro dos colchetes:\n\n\nletters[length(letters)]\n\n[1] \"z\"\n\nHá também uma função chamada tail(), que é mais lenta,\nmas é mais flexível:\n\n\ntail(letters,1)\n\n[1] \"z\"\n\nSe quiser obter os três últimos valores:\n\n\ntail(letters,3)\n\n[1] \"x\" \"y\" \"z\"\n\nEssas mesmas regras valem para listas em geral. Para dataframes, há\num pacote chamado dplyr(), o qual possui funções próprias\npara isso.\n\n\n\n",
    "preview": {},
    "last_modified": "2022-10-17T06:47:25-03:00",
    "input_file": "objetos.knit.md"
  },
  {
    "path": "posts/2022-10-06-sobrevivencia/",
    "title": "O tempo do processo judicial",
    "description": "Como calculo a duração do processo? Neste tutorial, introduzo uma metodologia própria para estimar o tempo desde a instauração até a apreciação do pedido. A análise de sobrevivência ou análise de duração compreende várias técnicas estatísticas para estimar a duração do processo.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://github.com/jjesusfilho"
      }
    ],
    "date": "2022-10-06",
    "categories": [],
    "contents": "\n\n\n\nA jurimetria inclui uma variedade de temas, métodos e técnicas\naplicadas ao direito. Duas delas, porém, sobressaem dentre as demais. O\ninteresse no desfecho processual e o interesse no tempo do processo.\nNeste tutorial, abordaremos o segundo, que é o tempo do processo.\nPara análise do tempo do processo, há uma técnica conhecida como\nanálise de sobrevivência, desenvolvida no âmbito da pesquisa em saúde,\nmas que é muito apropriada para entender a duração do processo desde o\npedido até sua apreciação ou qualquer outro ato processual de interesse.\nComo estamos trabalhando no âmbito do direito, de agora em diante,\nfalaremos em análise de duração, em vez de sobrevivência.\nA análise de duração é também conhecida como tempo para o evento\n(time-to-event). Basicamente, ela é composta por quatro elementos.\nSujeito. No presente caso, o processo judicial.\nData da exposição. No presente caso, a data da distribuição da ação,\nda instauração do inquérito ou do recurso.\nData do evento. Momento do ato processual.\nDuração. Tempo entre a data da exposição e a data do evento.\nO evento em si mesmo não é objeto da análise. Embora, como veremos\nadiante, a natureza do ato processual pode afetar significativamente o\ntempo do processo.\nExemplos\nEmpresa (sujeito) inicia atividade (exposição) até (duração)\nfalência (data do evento);\nCasal (sujeito) contrai matrimônio (exposição) até (duração) o\ndivórcio (data do evento).\nPessoa (sujeito) é diagnosticada com câncer (exposição) até\n(duração) sua morte (data do evento).\nProcesso judicial (sujeito) é distribuído (exposição) até (tempo)\nsua extinção (data do evento).\nConceitos chave\nAntes de mostrar como rodar uma análise de duração, é preciso ter\nfamiliaridade com alguns conceitos chave para este tipo de análise.\nCensura\nUm aspecto chave na análise de duração é a censura de dados. Quando\nnão se conhece o tempo até o evento para um indivíduo, diz-se que esse\ndado é censurado. Há três tipos de dados censurados.\nCensura à esquerda: Tj < x: O tempo para o evento é menor do\nque um valor particular. Esta é a situação em que o evento ocorre antes\ndo momento da exposição. Por exemplo, quando há arquivamento de\ninquérito, termo de ajustamento de conduta ou acordo sem que processo\ntenha sido instaurado.\nCensura intervalar: x1 < Tj < x2 Sabemos que o tempo para o\nevento está entre dois momentos, mas não sabemos quando isso ocorreu.\nPor exemplo, sabemos quando a ação foi distribuída e sabemos quando ela\nfoi julgada, mas não sabemos quando ocorreu a pronúncia, quando ocorreu\na apreciação do pedido de antecipação de tutela.\nCensura à direita: Tj > x: O tempo para um evento é maior que\num valor particular. Esta é a situação mais comum. Sabemos quando o\nprocesso foi instaurado, mas não quando foi julgado o mérito ou\napreciado o pedido de liminar, especialmente porque no momento de\ninteresse esta informação não estava disponível. Exemplo, ao coletar\ndados sobre mandado de segurança, verificamos que o pedido de liminar\nnão foi apreciado um mês após sua judicialização.\nA análise de duração leva em conta a censura de dados. Você verá mais\nadiante que incluiremos uma coluna em nossa tabela informando se o\nevento ocorreu ou se foi censurado. O tempo para o evento é sempre o\nmenor valor entre o tempo de censura e o tempo para o evento.\nFunções de sobrevivência e\nde risco\nOutro conceito importante é a probabilidade de que um processo\njudicial (sujeito) vai durar para além de um determinado tempo,\ncalculada por meio da função de sobrevivência ou de duração \\(S(t)\\). Se formos adaptar a linguagem para\no direito processual, podemos chamá-la de função de pendência e a\ncorrespondente probabilidade de pendência, vez que se estima a\nprobabilidade de que um pedido se encontra pendente num determinado\nmomento.\nAlém dela, existe a função de risco (hazard function) \\(h(t)\\), a qual calcula a probabilidade de\nque um ato processual foi realizado no tempo t.\nNote que a primeira foca na probabilidade de não ter ocorrido o\nevento, enquanto que a segunda, de ter ocorrido.\nMétodo Kaplan-Meier (KM)\nKaplan-meier é uma análise não paramétrica para estimar a\nprobabilidade de duração S(t). Não paramétrica significa que estimamos\nparâmetros e não assumimos que os valores seguem uma distribuição\nprobabilística específica, tal como a distribuição normal.\nPor este método, a função de duração S(t) é calculada da seguinte\nforma:\n\\[ S(t_i) = S(t_i-1)(1 -\n\\frac{d_i}{n_i})\\]\nEm que:\n\\(S(t_i - 1)\\)= Probabilidade do\npedido estar tramitando no tempo \\(t_i -\n1\\).\\(n_i\\) = Número de pedidos processuais\ntramitando imediatamente antes de \\(t_i\\).\\(d_i\\) = Número de eventos no tempo\n\\(t_i\\).\\(t_0 = 0, S(0) = 1\\)\nA função de duração \\(S(t)\\) apenas\naltera o valor no tempo de cada evento. É possível calcular o erro\npadrão e o intervalo de confiança da taxa de sobrevivência.\nKaplan-Meier permite também avaliar como grupos, por exemplo,\ntribunais ou varas diferem diferem no tempo de processamento.\nIgualmente, permite verificar como cada um dos grupos experimenta as\ncurvas de duração. Mais adiante, mostraremos como criar a curva\nKaplan-Meier.\nUma limitação do método Kaplan-Meier é que ele permite a inclusão de\nvariáveis categóricas apenas. Para incluir variáveis contínuas, temos de\nrecorrer ao risco proporcional \\(h(t)\\)\nde Cox. No presente tutorial, não abordaremos o Risco Proporcional de\nCox porque no exemplo oferecido não temos variáveis contínuas e, para\nnão sobrecarregar muito o leitor, trataremos do tema e outro\ntutorial.\nTempo do Habeas Corpus\nPara este tutorial, optamos por baixar pedidos de habeas corpus\nperante o Tribunal de Justiça de São Paulo contra atos de magistrados de\nprimeira instância. Inicialmente, pensamos em analisar o tempo até a\napreciação do pedido de liminar. No entanto, nem todos os HCs têm pedido\nde antecipação cautelar, muitas decisões concedem HC liminarmente\nindependentemente de haver pedido de antecipação. Muitos HCs, mesmo com\npedido de liminar, diferem o processamento até a apreciação de mérito.\nDessa forma, optamos por observar o tempo entre a entrada no TJSP até a\napreciação do mérito, independentemente se este foi decidido\nliminarmente ou não.\nPara esta análise, baixamos 3174\npedidos de HCs. Basicamente o que fizemos foi usar a função\ncnj_sequencial do pacote JurisMiner para criar\nduas sequências de números do CNJ. Uma que começa com 20, outra que\ncomeça com 00. Fizemos isso porque notamos que havia dois padrões de\nnumeração. O primeiro, que começa com 20, corresponde a habeas corpus\nimpetrados eletronicamente, geralmente por advogados, especialmente a\nDefensoria Pública. O segundo, que começa com 00, corresponde a HCs\nimpetrados pelos próprios pacientes ou seus familiares, geralmente\npresos com pedidos no âmbito da execução penal.\nColeta dos dados\nAdicionei esta seção, somente para documentação do procedimento de\ncoleta. Você pode saltá-la e ir diretamente para a análise. A base\nutilizada se encontra aqui.\nVeja abaixo como eu fiz. Primeiramente, criei um diretório chamado\ncpopsg (Consulta de julgados de segundo grau). Depois criei cada uma das\nsequências e coloquei para baixar os processos.\nNote que, antes de usar essas funções, você tem de instalar os\npacotes JurisMiner\ne tjsp:\nremotes::install_github(\"courtsbr/JurisMiner\")\nremotes::install_github(\"jjesusfilho/tjsp\")\nVamos carregar os pacotes acima e também o tidyverse, pois este é\nnossa principal ferramenta de ciência de dados.\n\n\nlibrary(tidyverse)\nlibrary(JurisMiner)\nlibrary(tjsp)\n\n\ndir.create(\"cposg\")\n\nsequencia <- cnj_sequencial(inicio = 2000001, ## início da sequência\n                                           fim = 2010000, ## fim da sequência\n                                           ano = 2022,  ## ano do processo\n                                           segmento = 8, ## Justiça estadual\n                                           tribunal = 26, ## TJSP\n                                           distribuidor = 0000 ## Segunda instância.\n                                           ) \n\ntjsp_baixar_cposg(sequencia, \"cposg\")\n\nsequencia <- cnj_sequencial(inicio = 0000001,\n                                           fim = 0010000,\n                                           ano = 2022, \n                                           segmento = 8,\n                                           tribunal = 26,\n                                           distribuidor = 0000)\n                                           \ntjsp_baixar_cposg(sequencia, diretorio = \"cposg\")\nDepois de baixar os htmls com os metadados processuais, a próxima\netapa é ler os dados básicos, a movimentação e a decisão. O pacote tjsp possui funções para\nisso.\narquivos <- list.files(\"cposg\", full. names = TRUE) ## Lista o caminho de cada arquivo\n\ndados <- tjsp_ler_dados_cposg(arquivos) ## importa para o R os dados básicos\nEsses dados são todos os 20 mil primeiros processos instaurados na\nsegunda instância do TJSP. Eles são, via de regra, ações autônomas.\nAntes de lermos a movimentação processual, bem como, as decisões,\nprecisamos filtrar para somente aquele que são habeas corpus\ncriminais.\ndados <- dados |> \n     filter(classe == \"Habeas Corpus Criminal\") ## Mantêm somente os habeas corpus.\nFeito isso, vamos criar uma tabela com os arquivos e, a partir dela,\ncriar uma coluna processo, extrair do nome do arquivo o número do\nprocesso para, então, filtrar somente aqueles que são HCs.\ntb <- tibble(arquivo = arquivos) |> ## Coloca o vetor de arquivos numa coluna de tibble\n      mutate(processo = str_extract(arquivo,\"\\\\d{20}\")) ## extrai os números dos processos.\n\ntb <- tb |> \n     semi_join(dados, by = \"processo\") ## Mantêm os arquivos cujos processos são HCs.\nAgora podemos ler somente as decisões e movimentações dos processos\nque são HC.\ndispositivos <- tjsp_ler_dispositivo(tb$arquivo)\n\nmovimentacao <- tjsp_ler_movimentacao(tb$arquivo)\nVamos visualizar a estrutura dos dados.\ndados |> \n sample_n(10) |> \n glimpse()\n\nRows: 10\nColumns: 21\n$ processo           <chr> \"00006152420228260000\", \"0003933152022826…\n$ digital            <lgl> TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE,…\n$ situacao           <chr> \"Arquivado administrativamente\", \"Arquiva…\n$ cd_processo        <chr> \"RI006Q23O0000\", \"RI006R09C0000\", \"RI006Q…\n$ v1                 <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA\n$ area               <chr> \"Criminal\", \"Criminal\", \"Criminal\", \"Crim…\n$ assunto            <chr> \"DIREITO PENAL - Crimes contra o Patrimôn…\n$ classe             <chr> \" Habeas Corpus Criminal\\n\", \" Petição Cr…\n$ distribuicao       <chr> NA, \" \\n\", \" \\n\", NA, \" \\n\", \" \\n\", NA, \"…\n$ orgao_julgador     <chr> \" 9ª Câmara de Direito Criminal\\n\", NA, N…\n$ origem             <chr> \"Comarca de Marília / Foro de Marília / V…\n$ outros_numeros     <chr> \"\\n                            \\n        …\n$ processo_principal <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA\n$ recebido_em        <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA\n$ recurso            <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA\n$ relator            <chr> \"CÉSAR AUGUSTO ANDRADE DE CASTRO\", NA, NA…\n$ revisor            <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA\n$ secao              <chr> \" Direito Criminal\\n\", \" Direito Criminal…\n$ ultima_carga       <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA\n$ valor_da_acao      <chr> NA, NA, NA, \"1.200,00\", NA, NA, \"1.000,00…\n$ volume_apenso      <chr> \"1 / 0\", \"1 / 0\", \"1 / 0\", \"1 / 0\", \"1 / …\n\nDesses dados, nós preservaremos somente o número do processo e o\nórgão julgador. Além disso, iremos manter somente as câmaras de direito\ncriminal, ajustar sua descrição e convertê-las em fator ordenado.\nIgualmente, iremos criar uma nova coluna com a informação de que o\nprocesso é originalmente físico, protocolado pelo preso, ou eletrônico\ndesde o início. Para tanto, basta verificar o início do processo. Se\ncomeça com 20 é totalmente eletrônico, com 00 é inicialmente físico, ou\nseja, o pedido foi possivelmente escrito a mão por um pessoa privada de\nliberdade.\nNão iremos usar a informação sobre o crime, mas assim mesmo, vamos\nreter a informação sobre o crime do assunto. Os casos em que não há\ninformação do crime parecem ser execução penal. Vamos converter esses\ncasos, sem informação sobre o crime, em execução penal.\nordenar_camaras <- function(x){\nstringr::str_remove_all(x, \"(\\\\s|[:lower:]+)\") %>% factor(.,levels = stringr::str_sort(unique(.),\nnumeric = T))\n}\n\ndados <- dados |> \n     mutate(crime = str_extract(assunto, \"(?<=-)[^-]+$\"), .after = assunto) ## extrai tudo que depois do último hífen.\n     mutate(crime = str_squish(crime)) |> ## remove espaços extra.\n     mutate(crime = ifelse(assunto == \"DIREITO PENAL\", \"Execução penal\", crime)) ## Se houver só a expressão DIREITO PENAL penal no assunto, converte o crime em Execução penal.\n      select(processo, orgao_julgador, crime) |> \n      mutate(camara = ordenar_camaras(orgao_julgador)) |> \n      mutate(fisico = ifelse(str_detect(processo, \"^0\"), \"sim\", \"não\"))\nA base dispositivos possui três colunas, processo, data e\ndispositivo. Além disso, nem todos os processos contêm a informação da\ndecisão. Na verdade, ao examinar a base é possível saber que houve\ndecisão e é até possível extraí-la da movimentação, mas vamos manter sem\nessa informação por razões pedagógicas a fim de ilustrar como dados\ncensurados são incorporados na análise.\nNo código abaixo, usamos a função tjsp_classificar_writ\npara extrair do dispositivo o teor da decisão. Não usaremos essa\ninformação, mas manteremos na base por sua eventual utilidade.\nIgualmente, extraímos a informação de que a concessão foi em caráter\nliminar ou não.\ndispositivos <- dispositivos |> \n           mutate(decisao = tjsp_classificar_writ(dispositivo)) |> \n          mutate(liminar = case_when(\n         str_detect(dispositivo,\"(?i)\\\\blimin\") ~ \"sim\",\n         TRUE ~ \"não\"\n       ))\nVamos extrair da movimentação a primeira movimentação de cada\nprocesso, que pode ser interpretada como a distribuição do HC.\n\ndistribuicao <- movimentacao |>\n           group_by(processo) |>\n           filter(data== min(data)) |>\n           slice(1) |> \n           select(processo, data_distribuicao = data)\nPor fim, vamos juntar essas três bases e criar uma nova coluna\nchamada duração, que é a diferença entre a data da distribuição e a data\nda decisão. O pacote tjsp tem uma função chamada lapso, que serve para\nisso. Iremos colocar a duração em dias porque a movimentação não informa\na hora. Iremos também adicionar uma coluna informando o status da\ninformação, se foi censurada terá valor 0, se não, valor 1.\nbase <- dispositivos |> \n        select(processo, liminar, data_decisao = data, decisao) |> \n        inner_join(dados, by = \"processo\") |> \n        inner_join(dispositivos, by = \"processo\") |> \n        mutate(duracao = lapso(inicio = data_distribuicao, \n                               fim = data_decisao, \n                               unidade = \"dia\")\n                               ) |> \n       mutate(status = ifelse(is.na(duracao),0, 1))\nPor fim, vamos ordenar as colunas e converter as variáveis\nindependentes em fatores\nbase <- base |> \nselect(processo, duracao, status, data_distribuicao, data_decisao,  status, camara,crime, liminar, fisico, decisao) |> \nmutate(across(crime:decisao, as.factor))\nAnálise\nEstamos em condições de aplicar a análise de duração. Antes, porém,\nvamos visualizar os dados. São 3174 pedidos julgados. No entanto, há 587\ncasos censurados porque “não sabemos” quando foram decididos. Sabemos,\nporém que foram julgados porque todos foram extintos.\n\n\nglimpse(base)\n\nRows: 3,174\nColumns: 10\n$ processo          <chr> \"00100009320228260000\", \"00099948620228260…\n$ duracao           <dbl> 28, 30, 30, 1000, 44, 9, 65, 20, 14, 61, 7…\n$ status            <dbl> 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ data_distribuicao <date> 2022-03-30, 2022-03-30, 2022-03-30, 2022-…\n$ data_decisao      <date> 2022-04-27, 2022-04-29, 2022-04-29, NA, 2…\n$ camara            <fct> 15CDC, 10CDC, 13CDC, 14CDC, 2CDC, 7CDC, 12…\n$ crime             <fct> \"Furto Qualificado\", \"Receptação Qualifica…\n$ liminar           <fct> não, não, não, não, não, não, não, não, si…\n$ formato           <fct> físico, físico, físico, físico, físico, fí…\n$ decisao           <fct> prejudicado/extinto, denegado, não conheci…\n\nPara a análise, iremos usar dois pacotes, o survival que\njá vem instalado com o R e survminer, que serve para gerar\ngráficos usando o ggplot2.\nInstale o surviminer:\ninstall.packages(\"survminer\")\nCarregue os dois pacotes:\n\n\nlibrary(survival)\nlibrary(survminer)\n\n\nDo pacote survival, usaremos duas funções, Surv e survfit. A primeira\ncria um objeto “survival” com informações sobre o tempo, o status e o\ntipo de censura. A segunda roda o modelo Kaplan-Meier com seus\nrespectivos estimadores.\nInicialmente, vamos rodar o modelo sem as variáveis categóricas. Note\nque eu crio, com a função Surv o objeto. Nela eu coloquei o tempo\n(duração) e o status. Além disso, está subentendido o tipo de censura,\nque é à direita.\n\n\nkm_fit <- survfit(Surv(duracao, status) ~ 1, data = base)\n\n\nOs resultados mostram que de 3.174 pedidos, tivemos 2.604 decisões\nconhecidas. As demais foram censuradas. A mediana é de 40 dias. A\nmediana é mais apropriada que a média em análise de duração porque a\ndistribuição das decisões é mais concentrada nos primeiros momentos, com\npoucos casos, mas importantes, com alta duração.\n\n\nkm_fit\n\nCall: survfit(formula = Surv(duracao, status) ~ 1, data = base)\n\n        n events median 0.95LCL 0.95UCL\n[1,] 3174   2604     40      39      42\n\nPara visualizar os resultados em mais detalhes, vamos usar a função\nsurv_summary do pacote survminer. Vamos também\nrenomear as colunas para nomes mais amigáveis em termos de\ncompreensão.\nMostraremos somente as 15 primeiras linhas e as 11 últimas para caber\nna página.\n\n\nsumario <- surv_summary(km_fit) |> \n        setNames(c(\"tempo_em_dias\",\"pedidos_pendentes\",\"pedidos_decididos\",\n        \"n_censurados\",\"prob_duracao\",\"erro\",\"ic_inferior\",\"ic_superior\")) |> \n   slice(c(1:15, 120:130))\n\nsumario\n\n\n\ntempo_em_dias\npedidos_pendentes\npedidos_decididos\nn_censurados\nprob_duracao\nerro\nic_inferior\nic_superior\n2\n3174\n3\n0\n0.9990548\n0.0005460\n1.0000000\n0.9979863\n3\n3171\n8\n0\n0.9965343\n0.0010468\n0.9985809\n0.9944920\n4\n3163\n4\n0\n0.9952741\n0.0012231\n0.9976629\n0.9928910\n5\n3159\n8\n0\n0.9927536\n0.0015165\n0.9957087\n0.9898073\n6\n3151\n18\n0\n0.9870825\n0.0020305\n0.9910187\n0.9831620\n7\n3133\n31\n0\n0.9773157\n0.0027042\n0.9825094\n0.9721495\n8\n3102\n34\n0\n0.9666037\n0.0032993\n0.9728745\n0.9603733\n9\n3068\n31\n0\n0.9568368\n0.0037699\n0.9639330\n0.9497928\n10\n3037\n23\n0\n0.9495904\n0.0040896\n0.9572325\n0.9420094\n11\n3014\n22\n0\n0.9426591\n0.0043778\n0.9507821\n0.9346055\n12\n2992\n14\n0\n0.9382483\n0.0045537\n0.9466597\n0.9299116\n13\n2978\n35\n0\n0.9272212\n0.0049729\n0.9363027\n0.9182278\n14\n2943\n32\n0\n0.9171393\n0.0053352\n0.9267800\n0.9075988\n15\n2911\n26\n0\n0.9089477\n0.0056179\n0.9190113\n0.8989943\n16\n2885\n38\n0\n0.8969754\n0.0060156\n0.9076136\n0.8864619\n144\n581\n1\n0\n0.1827347\n0.0375377\n0.1966859\n0.1697731\n148\n580\n1\n0\n0.1824197\n0.0375773\n0.1963620\n0.1694672\n152\n579\n1\n0\n0.1821046\n0.0376171\n0.1960382\n0.1691614\n161\n578\n1\n0\n0.1817895\n0.0376569\n0.1957143\n0.1688555\n167\n577\n1\n0\n0.1814745\n0.0376968\n0.1953904\n0.1685497\n168\n576\n1\n0\n0.1811594\n0.0377369\n0.1950665\n0.1682439\n173\n575\n1\n0\n0.1808444\n0.0377770\n0.1947425\n0.1679381\n190\n574\n1\n0\n0.1805293\n0.0378172\n0.1944186\n0.1676323\n227\n573\n1\n0\n0.1802142\n0.0378575\n0.1940946\n0.1673265\n234\n572\n1\n0\n0.1798992\n0.0378979\n0.1937706\n0.1670207\n237\n571\n1\n0\n0.1795841\n0.0379385\n0.1934466\n0.1667150\n\nVeja que o primeiro tempo é dois dias, ou seja, depois de dois dias,\nhavia 3174 casos, sendo que três casos foram julgados. Depois de três\ndias, oito casos foram julgados. A tabela também mostra o número de\npedidos pendentes depois de um certo número de dias. Também mostra a\nprobabilidade de pendência, ou seja, a probabilidade de o pedido não ter\nsido apreciado a cada momento.\nA curva de Kaplan-Meier é ilustrativa, veja abaixo. Limitamos no\ngráfico para 180 dias e colocamos intervalos de dez dias para facilitar\na visualização.\n\n\nggsurvplot(km_fit,\n           xlim = c(0,180),\n           break.time.by = 10,\n           ylab = \"Probabilidade de pendência\",\n           xlab = \"Tempo em dias\",\n           legend.title = \"Tempo para apreciar pedidos de habeas corpus\",\n           ggtheme = theme_light()\n           )\n\n\n\nVeja que a curva mostra a probabilidade de pendência ou duração ao\nlongo do tempo. Isto é, no tempo zero, 100% está pendente. Conforme o\ntempo passa, a taxa de pendência vai caindo.\nDuração por câmara\nVamos agora observar como ficam os tempos quando condicionamos por\ncâmara de direito criminal.\n\n\nkm_fit <- survfit(Surv(duracao, status) ~ camara, data = base)\n\n\nVocê pode visualizar os resultados com\nsurv_summary(km_fit). Aqui iremos apenas gerar os gráficos\ndas curvas de Kaplan-Meier para cada câmara de direito criminal.\n\n\ncurva <- ggsurvplot(km_fit,\n                    data = base,\n                    break.time.by = 15 ,\n                    xlim = c(0,120),\n                    ylab = \"Probabilidade de pendência\",\n                    xlab = \"Tempo em dias\",\n                    ggtheme = theme_light()\n                    )\n\n\najusta_etiqueta <- function(x) stringr::str_remove(x, \"camara=\")\n\ncurva$plot +\n  facet_wrap(~strata, labeller = as_labeller(ajusta_etiqueta)) +\n  theme(legend.position=\"none\")\n\n\n\nAs curvas sugerem diferenças entre as câmaras criminais. Algumas,\ncomo a quinta e a oitava câmaras decidem um número relevante de casos\nlogo nos primeiros dias. Por su vez, a 10ª e a 15ª demoram um pouco\nmais, mas suas curvas mostram uma redução relevante de casos depois de\num certo período.\nTeste Logrank\nPara saber se essas curvas são realmente diferentes, há um teste\nchamado logrank. Por meio dele, verifica-se de os grupos (câmaras de\ndireito criminal) experimentam diferenças nas curvas, i.e., dado um\nmomento, e.g., 5 dias após o pedido, o número de decisões é o mesmo para\ncada um, ou difere significativamente. Basicamente o teste compara o\nnúmero de decisões observadas e o número de decisões esperadas para cada\nmomento e apresenta a soma deles. O teste logrank adotado pelo R é uma\naproximação ao teste do Chi Quadrado. Se você não tem familiaridade com\no teste do Chi Quadrado, esse vídeo pode\nlhe ajudar.\nPara realizar o teste, há uma função específica:\n\n\nsurv_diff <- survdiff(Surv(duracao, status) ~ camara, data = base)\nsurv_diff\n\nCall:\nsurvdiff(formula = Surv(duracao, status) ~ camara, data = base)\n\n               N Observed Expected (O-E)^2/E (O-E)^2/V\ncamara=1CDC  191      162    149.2   1.09465   1.18900\ncamara=2CDC  165      144    106.4  13.26440  14.16525\ncamara=3CDC  192      142    196.8  15.26736  16.93715\ncamara=4CDC  225      187    231.1   8.40432   9.45539\ncamara=5CDC  164      149     98.6  25.74522  27.39508\ncamara=6CDC  231      142    200.6  17.11896  19.10198\ncamara=7CDC  216      191    183.1   0.34045   0.37579\ncamara=8CDC  306      290    210.2  30.26589  33.76487\ncamara=9CDC  190      190    105.4  67.79794  72.79231\ncamara=10CDC 133      110    128.7   2.71341   2.92378\ncamara=11CDC 190      176    115.6  31.59349  33.88838\ncamara=12CDC 153      138    137.6   0.00136   0.00148\ncamara=13CDC 186      126    178.6  15.48205  17.02984\ncamara=14CDC 204      143    194.1  13.45849  14.89480\ncamara=15CDC 224      157    204.1  10.86918  12.08055\ncamara=16CDC 204      157    163.8   0.28635   0.31276\n\n Chisq= 264  on 15 degrees of freedom, p= <2e-16 \n\nComo se pode observar dos resultados, há diferenças significativas\nentre as câmaras, p-valor < 0.05. Algumas decidiram mais hebeas\ncorpus do que o esperado a cada momento, outras ficaram aquém do\nesperado.\nDuração com múltiplas\nvariáveis.\nVamos agora incluir o formato entre as variáveis condicionantes do\ntempo para julgar um HC e ver os resultados grafivamente.\n\n\nkm_fit <- survfit(Surv(duracao, status) ~ camara + formato, data = base)\n\ncurva <- ggsurvplot(km_fit,\n                    data = base,\n                    break.time.by = 20 ,\n                    xlim = c(0,120),\n                    ylab = \"Probabilidade de pendência\",\n                    xlab = \"Tempo em dias\",\n                    ggtheme = theme_light()\n                    )\n\n\nremove_nome <- function(x) stringr::str_remove_all(x, \"\\\\w+=\")\n\ncurva$plot +\n  facet_wrap(~strata, labeller = as_labeller(remove_nome))+\n  theme(legend.position=\"none\")\n\n\n\nQuando olhamos para algumas câmaras, como a 13ª e a 15ª, os processos\neletrônicos são julgados muito mais rapidamente e, pior, a maioria dos\npedidos físicos nem sequer foram julgados no tempo de 120 dias mostrado\nno gráfico.\nIndo além\nEsse tutorial quis ilustrar o potencial da análise de duração para a\njurimetria. Nem sequer exploramos o tema profundamente. Há muito mais\nquestões que podem ser exploradas, como saber se decisões quem tendem a\nnegar o HC saem mais rapidamente ou não. Igualmente, decisões liminares\nestão sujeitas ao fumus boni iuris e ao periculum in mora.\nPossivelmente, os tempos se invertem quando deferir uma liminar\nsupostamente gera um perigo (HC) ou quando a o indeferimento gera perigo\n(medidas protetivas.)\nA base está disponível\npara você analisá-la e explorar esses outros aspectos.\n\n\n\n",
    "preview": "posts/2022-10-06-sobrevivencia/sobrevivencia_files/figure-html5/unnamed-chunk-10-1.png",
    "last_modified": "2022-10-13T07:49:25-03:00",
    "input_file": "sobrevivencia.knit.md",
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/welcome/",
    "title": "Jurimetria",
    "description": "Blog voltado à comunidade jurídica interessada em jurimetria.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://github.com/jjesusfilho"
      }
    ],
    "date": "2022-04-29",
    "categories": [],
    "contents": "\n\n\n\n",
    "preview": {},
    "last_modified": "2022-04-29T11:23:40-03:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-04-29-como-baixar-dados-do-tjsp/",
    "title": "Como baixar dados do TJSP",
    "description": "Nesta primeira postagem do blog, falaremos sobre como baixar e estruturar dados do Tribunal de Justiça de São Paulo. Nas próximas, veremos como agregar valor a esses dados e como aplicar técnicas de machine learning  e métodos estatísticos para analisar e fazer predições.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://github.com/jjesusfilho"
      }
    ],
    "date": "2022-04-29",
    "categories": [],
    "contents": "\nO texto inaugural mostra como baixar dados processuais do Tribunal de\nJustiça de São Paulo (TJSP), bem como, estruturá-los e deixá-los prontos\npara análise.\nO único pré-requisito é ter noções básicas de programação em R.\nSe você não sabe R e quiser aprender para aplicar à jurimetria, eu\nmantenho um curso Jurimetria\nAplicada.\nInicialmente, vamos instalar o pacote tjsp, o qual tem todas as\nferramentas que você necessita para baixar e organizar os dados do TJSP.\nPara instalar o pacote tjsp, você deve ter o pacote remotes\ninstalado.\nremotes::install_package(\"jjesusfilho/tjsp\")\nO pacote tjsp possui muitas funções para baixar e organizar os dados\ndo TJSP. Ele segue uma sintaxe simples. A maioria das funções começa com\ntjsp_, seguido do verbo indicador da ação, e.g., baixar, seguido da\nsigla do repositório. Basicamente, o sistema esaj, responsável por\ndisponibilizar os dados processuais do TJSP em meio eletrônico, usa\nquatro siglas:\ncjsg para consulta de julgados de segundo grau (busca\njurisprudencia), nesta\npágina.\ncjpg para consulta de julgados de primeiro grau, nesta página.\ncposg para consulta dos dados processuais de segundo grau (dados\nde capa) e movimentação processual, nesta página.\ncpopg para consulta dos dados processuais de primeiro grau (dados\nde capa ) mais movimentação processual, nesta página.\nDessa forma, para baixar um consulta jurisprudencial, você usa a\nfunção tjsp_baixar_cjsg(). Para baixar os dados de capa de\num processo de primeiro grau, você usa a função\ntjsp_baixar_cpopg(). Dentro delas, você vai informar os\nmesmos dados que você informaria na consulta diretamente àquelas\npáginas.\nConsulta jurisprudencial\nA título de exemplo, vamos baixar alguns julgados de segundo grau. Se\nvocê consultar a ajuda da função tjsp_baixar_cjsg(), verá\nque ela tem quase os mesmos parâmetros que você usaria na página do\nTJSP:\nlibrary(tjsp)\n\n?tjsp_baixar_cjsg\ntjsp_baixar_cjsg(\n  livre = \"\",\n  aspas = FALSE,\n  classe = \"\",\n  assunto = \"\",\n  orgao_julgador = \"\",\n  inicio = \"\",\n  fim = \"\",\n  inicio_pb = \"\",\n  fim_pb = \"\",\n  tipo = \"A\",\n  n = NULL,\n  diretorio = \".\"\n)\nO primeiro argumento da função chama-se livre, o qual corresponde à\n“Pesquisa livre` na página referida. Há outros argumentos, como a\nespecificação do assunto ou da classe processual. Hoje usaremos somente\na busca livre e o argumento n, o qual indica o número de páginas. Além\ndeles, indicaremos, no argumento diretorio, onde queremos baixar as\nconsultas:\nVamos fazer um experimento com a palavra “feminicídio”. Vamos criar\num diretório chamado feminicidio (sem acento) e, dentro dele, um outro\nchamado cjsg.\ndir.create(\"feminicidio\")\n\ndir.create(\"feminicidio/cjsg\")\nA consulta por feminicídio resultou em mais de 2500 julgados de\nsegundo grau. Vamos baixar apenas as primeiras 10 páginas da consulta.\nVeja abaixo como ficará a consulta.\ntjsp_baixar_cjsg(livre = \"feminicídio\",\n                 n  = 10,\n                 diretorio = \"feminicidio/cjsg\")\nForam baixados os htmls. Agora vamos ler esses htmls a fim de\nvisualizá-los. O único argumento que você precisa informar é o diretorio\nonde foram salvos os htmls.\ncjsg <- tjsp_ler_cjsg(diretorio = \"feminicidio/cjsg\")\nO resultado é a criação de um dataframe como na imagem abaixo.\n\n\n\nAs colunas lidas são as seguintes:\n\nRows: 200\nColumns: 10\n$ classe          <chr> \"Habeas Corpus Criminal\", \"Apelação Criminal…\n$ assunto         <chr> \"Furto Qualificado\", \"Homicídio Qualificado\"…\n$ relator         <chr> \"Eduardo Abdalla\", \"Camargo Aranha Filho\", \"…\n$ comarca         <chr> \"Mairiporã\", \"Ibiúna\", \"Araçatuba\", \"São Vic…\n$ orgao_julgador  <chr> \"6ª Câmara de Direito Criminal\", \"16ª Câmara…\n$ data_julgamento <date> 2022-04-28, 2022-04-28, 2022-04-28, 2022-04…\n$ data_publicacao <date> 2022-04-28, 2022-04-28, 2022-04-28, 2022-04…\n$ processo        <chr> \"20665325320228260000\", \"0002365312019826023…\n$ ementa          <chr> \"HABEAS CORPUS. Pretendida revogação da pris…\n$ cdacordao       <chr> \"15617778\", \"15617979\", \"15618448\", \"1561631…\n\nConsulta processual\nO próximo passo é consultar os dados de capa desses processos. No\nentanto, para automatizar a coleta de dados processuais, é necessário identificar-se antes\ncom CPF e senha. Se você está cadastrada no esaj, use a função abaixo.\nEla irá abrir um caixa para você incluir seu cpf e senha.\ntjsp_autenticar()\nVamos criar um diretório chamado “cposg” dentro do diretório\n“feminicidio”.\ndir.create(\"feminicidio/cposg\")\nAgora vamos baixar os processos para a pasta criada. Iremos usar a\ncoluna processo do dataframe cjsg. Para usá-la, basta colocar o cifrão\nentre o nome do dataframe e o nome da coluna.\ntjsp_baixar_cposg(cjsg$processo, diretorio = \"feminicidio/cposg\")\nA leitura dos htmls contendo as informações ocorre em quatro etapas.\nInicialmente, nós lemos os dados de capa propriamente ditos, número do\nprocesso, magistrado, comarca, vara etc. Em seguida, lemos os dados das\npartes. Depois lemos a movimentação processual e, por fim, lemos o\ndispositivo do acórdão.\nPara isso, primeiramente listamos todos os arquivos, para então usar\no caminho dos arquivos para “parsear” cada um dos grupos de dados\nmencionados acima. A função abaixo lista todos os htmls.\narquivos <- list.files(\"feminicidio/cposg\",full.names = TRUE)\nDados de capa\nAgora vamos usar esses arquivos para ler os dados de capa.\ndados <- tjsp_ler_dados_cposg(arquivos)\nAbaixo as colunas desses dados:\n\nRows: 230\nColumns: 15\n$ processo       <chr> \"00000417220218260408\", \"00000433520128260383…\n$ cd_processo    <chr> \"RI006OGX10000\", \"RI006K3E10000\", \"RI006KX4S0…\n$ area           <chr> \"Criminal\", \"Criminal\", \"Criminal\", \"Criminal…\n$ assunto        <chr> \"DIREITO PENAL-Crimes contra a vida-Feminicíd…\n$ classe         <chr> \" Recurso em Sentido Estrito\\n\", \" Recurso em…\n$ distribuicao   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ orgao_julgador <chr> \" 16ª Câmara de Direito Criminal\\n\", \" 2ª Câm…\n$ origem         <chr> \"Comarca de Ourinhos / Foro de Ourinhos / 2ª …\n$ outros_numeros <chr> \"\\n                            \\n            …\n$ relator        <chr> \"LEME GARCIA\", \"ANDRÉ CARVALHO E SILVA DE ALM…\n$ revisor        <chr> NA, NA, \"ALBERTO ANDERSON FILHO\", \"RACHID VAZ…\n$ secao          <chr> \" Direito Criminal\\n\", \" Direito Criminal\\n\",…\n$ ultima_carga   <chr> NA, \"\\n                            Origem: Se…\n$ valor_da_acao  <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ volume_apenso  <chr> \"0 / 0\", \"3 / 1\", \"1 / 0\", \"1 / 0\", \"1 / 0\", …\n\nPartes\npartes <- tjsp_ler_partes(arquivos)\n\nRows: 554\nColumns: 4\n$ processo      <chr> \"00000417220218260408\", \"00000417220218260408\"…\n$ tipo_parte    <chr> \"Recorrente:\", \"Recorrido:\", \"Recorrente:\", \"R…\n$ parte         <chr> \"Ministério Público do Estado de São Paulo\", \"…\n$ representante <chr> NA, \"Advogada:&nbsp\\n\\t\\t  \\n\\t\\t\\t  \\n\\t\\t\\t …\n\nMovimentação processual\nO mesmo fazemos com a movimentação processual.\nmovimentacao <- tjsp_ler_movimentacao(arquivos)\nPara visualizar os dados:\n\nRows: 7,518\nColumns: 3\n$ processo     <chr> \"00000417220218260408\", \"00000417220218260408\",…\n$ data         <date> 2022-04-20, 2022-04-20, 2022-04-19, 2022-04-19…\n$ movimentacao <chr> \"Prazo\", \"Publicado em\\n            \\n        \\…\n\nDispositivos\nPor fim, lemos os dispositivos:\ndispositivos <- tjsp_ler_dispositivo(arquivos)\nE visualizamos:\n\nRows: 230\nColumns: 3\n$ processo    <chr> \"00000417220218260408\", \"00000433520128260383\", …\n$ data        <date> 2022-04-12, 2022-04-08, 2022-03-18, 2022-02-17,…\n$ dispositivo <chr> \"Negaram provimento ao recurso. V. U. Sustentou …\n\nNeste tutorial, vimos apenas como baixar e estruturar esses dados em\ndataframes. Nos próximos, veremos como agregar valor a esses dados. Por\nexemplo, podemos classificar as decisões se procedentes ou\nimprocedentes. Podemos analisar o tempo do processo.\nHá muito mais pela frente. Aguarde os próximos tutoriais.\n\n\n\n",
    "preview": "posts/2022-04-29-como-baixar-dados-do-tjsp/feminicidio2.png",
    "last_modified": "2022-10-06T06:24:02-03:00",
    "input_file": "como-baixar-dados-do-tjsp.knit.md",
    "preview_width": 1286,
    "preview_height": 616
  }
]
