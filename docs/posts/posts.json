[
  {
    "path": "posts/2022-12-26-json-no-rparte1/",
    "title": "Json no R - Parte 1",
    "description": "Este é o primeiro tutorial de dois sobre JSON no R. Nesta primeira parte, mostro como usar o pacote `jsonlite` para converter de JSON para R e vice-versa. Na próxima postagem, trato de como trabalhar com JSON como JSON mesmo no R, sem convertê-lo para lista ou dataframe.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://github.com/jjesusfilho"
      }
    ],
    "date": "2022-12-26",
    "categories": [],
    "contents": "\nUm dos formatos de arquivos que eu mais gosto de trabalhar é JSON (JavaScript Object Notation). A graça de JSON é ser um formato amigável para seres humanos e para máquinas. Coloco abaixo o exemplo de parte de um currículo.\n{\n    \"id\": 2,\n    \"data\": \"2022-01-01\",\n    \"nome\": {\n        \"primeiro_nome\": \"José\",\n        \"sobrenome\": \"de Jesus Filho\"\n    },\n    \"cpf\": \"123.456.789-34\",\n    \"disponivel\": true,\n    \"educacao\": [\n        {\n            \"escola\": \"EMPG Milton Campos\",\n            \"ensino\": \"Fundamental\",\n            \"inicio\": 1982,\n            \"fim\": 1989\n        },\n        {\n            \"escola\": \"Derville Allegretti\",\n            \"ensino\": \"medio\",\n            \"inicio\": 1990,\n            \"fim\": 1992\n        }\n    ],\n    \"experiencia_profissional\": [\n        {\n            \"empresa\": \"Companhia Brasileria de Distribuição\",\n            \"cargo\": \"empacotador\",\n            \"inicio\": 1986,\n            \"fim\": 1988\n        },\n        {\n            \"empresa\": \"Compneus\",\n            \"cargo\": \"gerente\",\n            \"inicio\": 1990,\n            \"fim\": 1992\n        },\n        {\n            \"empresa\": \"Varias\",\n            \"cargo\": \"muitos\",\n            \"inicio\": 1992,\n            \"fim\": 2021\n        },\n        {\n            \"empresa\": \"MPSP\",\n            \"cargo\": \"Jurimetrista\",\n            \"inicio\": 2022,\n            \"fim\": null\n        }\n    ]\n}\nDiferentemente de XML, JSON é simples e fácil de manipular. No entanto, essa simplicidade vem com um custo. JSON carece de namespace, o que facilmente pode gerar conflitos e perda de integridade dos dados. Se você quer entender para que serve namespace, carregue o pacote dplyr e busque a ajuda para a função filter, você notará que há duas funções distintas com o mesmo nome, porém uma no namespace dplyr e outra no stats. Pacotes são namespaces, schemas em SQL são namespaces e XML também usa namespaces. Namespaces asseguram unicidade nos nomes dos objetos.\nAdemais, JSON só reconhece quatro (4) tipos/classes de dados (texto, número, boleano e nulo). Datas e dados categóricos (fatores ou enum) não são reconhecidos. Além disso, JSON têm duas estruturas universais:\nJSON objeto: Uma coleção desordenada de pares chave/valor. Esses valores podem ser aqueles acima mencionados: texto (string), número (number), boleano (boolean) e nulo, bem como os próprios objetos JSON e arrays.\nJSON array: Uma coleção ordenada de valores.\nNote acima que o JSON está dentro de chaves {…}, indicando que se trata de um objeto JSON. Nele há vários objetos: id, data, nome, cpf, disponivel, educacao e experiencia_profissional. O id é numérico, data, nome e cpf são textos e disponível é lógico (boleano). Por sua vez, educacao e experiencia_profissional são arrays. Arrays estão sempre entre colchetes.\nPerceba também que as chaves ou nomes (keys) estão sempre entre aspas e os valores, quando textos também entre aspas, números, boleanos e nulos (último ítem “fim” da experiência profissional), sem aspas.\nO exemplo acima é simples e fácil de entender, mas JSON pode ser complexo, com profundos aninhamentos de objetos e arrays, o que torna a conversão de um JSON para um objeto nativo do R e vice-versa um desafio e sujeita a erros de toda sorte.\nNeste tutorial, mostraremos como trabalhar como pacote jsonlite, o qual converte JSON em objetos do R e vice-versa. No próximo, falaremos do pacote jqr, o qual manuseia JSON como JSON mesmo, sem convertê-lo para lista ou data.frame.\nO pacote jsonlite\nO pacote jsonlite permite ler, escrever e validar JSONs. Vamos tratar do exemplo acima:\n\n\nx <- '{\n    \"id\": 2,\n    \"data\": \"2022-01-01\",\n    \"nome\": {\n        \"primeiro_nome\": \"José\",\n        \"sobrenome\": \"de Jesus Filho\"\n    },\n    \"cpf\": \"123.456.789-34\",\n    \"disponivel\": true,\n    \"educacao\": [\n        {\n            \"escola\": \"EMPG Milton Campos\",\n            \"ensino\": \"Fundamental\",\n            \"inicio\": 1982,\n            \"fim\": 1989\n        },\n        {\n            \"escola\": \"Derville Allegretti\",\n            \"ensino\": \"medio\",\n            \"inicio\": 1990,\n            \"fim\": 1992\n        }\n    ],\n    \"experiencia_profissional\": [\n        {\n            \"empresa\": \"Companhia Brasileria de Distribuição\",\n            \"cargo\": \"empacotador\",\n            \"inicio\": 1986,\n            \"fim\": 1988\n        },\n        {\n            \"empresa\": \"Compneus\",\n            \"cargo\": \"gerente\",\n            \"inicio\": 1990,\n            \"fim\": 1992\n        },\n        {\n            \"empresa\": \"Varias\",\n            \"cargo\": \"muitos\",\n            \"inicio\": 1992,\n            \"fim\": 2021\n        },\n        {\n            \"empresa\": \"MPSP\",\n            \"cargo\": \"Jurimetrista\",\n            \"inicio\": 2022,\n            \"fim\": null\n        }\n    ]\n}'\n\n\no pacote jsonlite possui um função para converter JSON para objeto do R chamada fromJSON:\n\n\nlibrary(jsonlite)\nobj <- fromJSON(x)\n\nobj\n\n$id\n[1] 2\n\n$data\n[1] \"2022-01-01\"\n\n$nome\n$nome$primeiro_nome\n[1] \"José\"\n\n$nome$sobrenome\n[1] \"de Jesus Filho\"\n\n\n$cpf\n[1] \"123.456.789-34\"\n\n$disponivel\n[1] TRUE\n\n$educacao\n               escola      ensino inicio  fim\n1  EMPG Milton Campos Fundamental   1982 1989\n2 Derville Allegretti       medio   1990 1992\n\n$experiencia_profissional\n                               empresa        cargo inicio  fim\n1 Companhia Brasileria de Distribuição  empacotador   1986 1988\n2                             Compneus      gerente   1990 1992\n3                               Varias       muitos   1992 2021\n4                                 MPSP Jurimetrista   2022   NA\n\nA vantagem do jsonlite é que ele opera um excelente mapeamento entre JSON e objetos do R. O JSON foi convertido numa lista de sete elementos, dos quais alguns vetores de um único elemento, nome é uma lista, e educacao e experiencia_profissional são dataframes. Além disso, os textos foram convertidos para characters, números tornaram-se integers, true foi propriamente convertido para TRUE e null para NA.\nA data foi mantida como character porque JSON não tem especificação para datas.\nO pacote jsonlite possibilita o caminho reverso por meio da função toJSON:\n\n\ntoJSON(obj)\n\n{“id”:[2],“data”:[“2022-01-01”],“nome”:{“primeiro_nome”:[“José”],“sobrenome”:[“de Jesus Filho”]},“cpf”:[“123.456.789-34”],“disponivel”:[true],“educacao”:[{“escola”:“EMPG Milton Campos”,“ensino”:“Fundamental”,“inicio”:1982,“fim”:1989},{“escola”:“Derville Allegretti”,“ensino”:“medio”,“inicio”:1990,“fim”:1992}],“experiencia_profissional”:[{“empresa”:“Companhia Brasileria de Distribuição”,“cargo”:“empacotador”,“inicio”:1986,“fim”:1988},{“empresa”:“Compneus”,“cargo”:“gerente”,“inicio”:1990,“fim”:1992},{“empresa”:“Varias”,“cargo”:“muitos”,“inicio”:1992,“fim”:2021},{“empresa”:“MPSP”,“cargo”:“Jurimetrista”,“inicio”:2022}]}\n\nA primeira observação é que JSON não está nada elegante nem formatado para facilitar a leitura humana. Igualmente, percebe-se que os vetores de um único elemento foram todos convertidos em arrays. Por fim, a chave-valor fim do último cargo, que era NA no R simplesmente desapareceu.\nA função toJSON possui argumentos para reverter isso.\n\n\ntoJSON(obj, \n      pretty = T, ## Tornar amigável ao usuário\n      na = \"null\", ## converte NA para nulo\n      auto_unbox = TRUE) ## retira os colchetes dos elementos únicos.\n\n{\n  \"id\": 2,\n  \"data\": \"2022-01-01\",\n  \"nome\": {\n    \"primeiro_nome\": \"José\",\n    \"sobrenome\": \"de Jesus Filho\"\n  },\n  \"cpf\": \"123.456.789-34\",\n  \"disponivel\": true,\n  \"educacao\": [\n    {\n      \"escola\": \"EMPG Milton Campos\",\n      \"ensino\": \"Fundamental\",\n      \"inicio\": 1982,\n      \"fim\": 1989\n    },\n    {\n      \"escola\": \"Derville Allegretti\",\n      \"ensino\": \"medio\",\n      \"inicio\": 1990,\n      \"fim\": 1992\n    }\n  ],\n  \"experiencia_profissional\": [\n    {\n      \"empresa\": \"Companhia Brasileria de Distribuição\",\n      \"cargo\": \"empacotador\",\n      \"inicio\": 1986,\n      \"fim\": 1988\n    },\n    {\n      \"empresa\": \"Compneus\",\n      \"cargo\": \"gerente\",\n      \"inicio\": 1990,\n      \"fim\": 1992\n    },\n    {\n      \"empresa\": \"Varias\",\n      \"cargo\": \"muitos\",\n      \"inicio\": 1992,\n      \"fim\": 2021\n    },\n    {\n      \"empresa\": \"MPSP\",\n      \"cargo\": \"Jurimetrista\",\n      \"inicio\": 2022,\n      \"fim\": null\n    }\n  ]\n} \n\nSe você quiser salvar um objeto do R como JSON, use a função write_JSON com os mesmos argumentos da toJSON adicionados do argumento path:\nwrite_JSON(obj,\n          path = \"curriculo.JSON\",\n          pretty = TRUE,\n          na = \"JSON\",\n          auto_unbox = TRUE)\nPreservando atributos de objetos R\nPor vezes, você quer converter um objeto R para JSON e revertê-lo posteriormente para R. A título de exemplo, vamos criar simples tibble e convertê-la para JSON.\n\n\ndf <- tibble::tibble(a = 1:5, b = letters[1:5])\n\nJSON <- toJSON(df, pretty = TRUE)\n\nJSON\n\n[\n  {\n    \"a\": 1,\n    \"b\": \"a\"\n  },\n  {\n    \"a\": 2,\n    \"b\": \"b\"\n  },\n  {\n    \"a\": 3,\n    \"b\": \"c\"\n  },\n  {\n    \"a\": 4,\n    \"b\": \"d\"\n  },\n  {\n    \"a\": 5,\n    \"b\": \"e\"\n  }\n] \n\nSe quisermos nossa tibble de volta, o resultado pode ser frustrante:\n\n\ntb <- fromJSON(JSON)\n\nclass(tb)\n\n[1] \"data.frame\"\n\nO pacote jsonlite oferece duas alternativas a toJSON e fromJSON, as quais preservam os atributos originais:\n\n\nsJSON <- serializeJSON(df, pretty = T)\nsJSON\n\n{\n  \"type\": \"list\",\n  \"attributes\": {\n    \"class\": {\n      \"type\": \"character\",\n      \"attributes\": {},\n      \"value\": [\"tbl_df\", \"tbl\", \"data.frame\"]\n    },\n    \"row.names\": {\n      \"type\": \"integer\",\n      \"attributes\": {},\n      \"value\": [1, 2, 3, 4, 5]\n    },\n    \"names\": {\n      \"type\": \"character\",\n      \"attributes\": {},\n      \"value\": [\"a\", \"b\"]\n    }\n  },\n  \"value\": [\n    {\n      \"type\": \"integer\",\n      \"attributes\": {},\n      \"value\": [1, 2, 3, 4, 5]\n    },\n    {\n      \"type\": \"character\",\n      \"attributes\": {},\n      \"value\": [\"a\", \"b\", \"c\", \"d\", \"e\"]\n    }\n  ]\n} \n\nO JSON resultante é mais verboso, mas assegura o retorno ao objeto R original:\n\n\nutb <- unserializeJSON(sJSON)\nclass(utb)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\nSe quisermos imprimir a tibble:\n\n\nutb\n\n# A tibble: 5 × 2\n      a b    \n* <int> <chr>\n1     1 a    \n2     2 b    \n3     3 c    \n4     4 d    \n5     5 e    \n\nHá outros recursos no pacote, como imprimir objetos json de forma bonita (prettify), mas creio que o essencial foi falado. Não se esqueça de ler o tutorial 2, nele mostramos uma infinidade de recursos para trabalhar com JSON.\n\n\n\n",
    "preview": {},
    "last_modified": "2022-12-26T09:35:01-03:00",
    "input_file": "json-no-rparte1.knit.md"
  },
  {
    "path": "posts/2022-12-26-json-no-rparte2/",
    "title": "Json no R_parte2",
    "description": "Este é o segundo tutorial sobre JSON no R. Na [primeira parte](https://direitoemdados.consudata.com.br/posts/2022-12-26-json-no-rparte1/), trabalhamos com o pacote `jsonlite`, que converte json para R. Neste, trabalhamos com o pacote `jqr`, o qual manuseia o json por ele mesmo.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://github.com/jjesusfilho"
      }
    ],
    "date": "2022-12-26",
    "categories": [],
    "contents": "\nPacote jqr\nDiferentemente do jsonlite, o jqr opera com JSON como JSON mesmo. Ele é uma implementação da biblioteca jq: (http://stedolan.github.io/jq/) no R. Há duas interfaces, uma de baixo nível, que emula o jq via linha de comando, ou de alto nível que adota funções do R. Primeiramente, mostraremos como o baixo nível porque ele é rico em recursos e uma vez que o conhece, você pode usá-lo inclusive na linha de comando.\nInstalação\nPara instalar os binários no Mac e no Windows, basta chamar:\ninstall.packages(\"jqr\")\nNo Linux, você tem de instalar o biblioteca a libjq-dev antes.\nBaixo nível\nNo baixo nível, você tem apenas de chamar a função jq e colocar entre aspas aquilo que você escreveria se estivesse usando jq no terminal. A biblioteca jq tem um playground para você testar: (https://jqplay.org/).\nVamos retomar currículo criado no primeiro tutorial:\n\n\nx <- '{\n    \"id\": 2,\n    \"data\": \"2022-01-01\",\n    \"nome\": {\n        \"primeiro_nome\": \"José\",\n        \"sobrenome\": \"de Jesus Filho\"\n    },\n    \"cpf\": \"123.456.789-34\",\n    \"disponivel\": true,\n    \"educacao\": [\n        {\n            \"escola\": \"EMPG Milton Campos\",\n            \"ensino\": \"Fundamental\",\n            \"inicio\": 1982,\n            \"fim\": 1989\n        },\n        {\n            \"escola\": \"Derville Allegretti\",\n            \"ensino\": \"medio\",\n            \"inicio\": 1990,\n            \"fim\": 1992\n        }\n    ],\n    \"experiencia_profissional\": [\n        {\n            \"empresa\": \"Companhia Brasileria de Distribuição\",\n            \"cargo\": \"empacotador\",\n            \"inicio\": 1986,\n            \"fim\": 1988\n        },\n        {\n            \"empresa\": \"Compneus\",\n            \"cargo\": \"gerente\",\n            \"inicio\": 1990,\n            \"fim\": 1992\n        },\n        {\n            \"empresa\": \"Varias\",\n            \"cargo\": \"muitos\",\n            \"inicio\": 1992,\n            \"fim\": 2021\n        },\n        {\n            \"empresa\": \"MPSP\",\n            \"cargo\": \"Jurimetrista\",\n            \"inicio\": 2022,\n            \"fim\": null\n        }\n    ]\n}'\n\n\nExtração\nSuponha que você queira extrair do currículo acima o cpf. Basta chamar a função jq() e colocar dentro de aspas o elemento precedido por ponto.\n\n\nlibrary(jqr)\n\nx |> \n  jq(\".cpf\")\n\n\"123.456.789-34\"\n\nVocê pode usar essa mesma sintaxe para obter subelementos.\n\n\nx |> \n  jq(\".nome.sobrenome\")\n\n\"de Jesus Filho\"\n\nSe quiser obter o primeiro elemento do array educacao, use colchetes:\n\n\nx |> \n  jq(\".educacao[0]\")\n\n{\n    \"escola\": \"EMPG Milton Campos\",\n    \"ensino\": \"Fundamental\",\n    \"inicio\": 1982,\n    \"fim\": 1989\n}\n\nNote que JSON começa a contar do zero.\nSe quiser a escola do segundo elemento de educacao:\n\n\nx |> \n  jq(\".educacao[1].escola\")\n\n\"Derville Allegretti\"\n\nCom pipe do R:\n\n\nx |> \n   jq(\".nome\") |> \n   jq(\".primeiro_nome\")\n\n\"José\"\n\ncom pipe do qr:\n\n\nx |> \n   jq(\".nome|.primeiro_nome\")\n\n\"José\"\n\nObjeto faltante\nE se você quiser algo que não existe:\n\n\nx |> \n  jq(\".idade\")\n\nnull\n\nA sintaxe acima funciona bem quando a chave (key) é simples, começa com uma letra e contêm somente dígitos e sublinhado. Isso aqui não funciona:\n\n\n'{\"1a\": 4, \"&b\": 6}' |> \n  jq('.1a')\n\nError: jq: error: syntax error, unexpected IDENT, expecting $end (Unix shell quoting issues?) at <top-level>, line 1:\n.1a  \n\nMas se você colocar a chave entre colchetes, funciona porque esta é a forma segura:\n\n\n'{\"1a\": 4, \"&b\": 6}' |> \n  jq('.[\"1a\"]')\n\n4\n\nVírgula\nSe você separar os filtros por vírgula, ele roda cada um deles e retorna um array:\n\n\n'{\"primeiro_nome\": \"José\",\"sobrenome\": \"de Jesus Filho\"}' |> \n  jq('.primeiro_nome, .sobrenome')\n\n[\n    \"José\",\n    \"de Jesus Filho\"\n]\n\nFatiamento\nSe o seu JSON é um array, você pode fatiá-lo. No entanto, ele começa a contar do zero e, assim como em Python, o último índice não entra. Isso pode parecer estranho para usuários de R, mas com o tempo você se acostuma.\n\n\n'[\"a\", \"b\", \"c\", \"d\", \"e\"]' |> \n  jq(\".[2:4]\")\n\n[\n    \"c\",\n    \"d\"\n]\n\nVários valores com getpath:\n\n\nx |> \n  jq('getpath([\"nome\", \"primeiro_nome\"], [\"nome\",\"sobrenome\"])')\n\n[\n    \"José\",\n    \"de Jesus Filho\"\n]\n\nSubstituição\nSubstituição é tão simples quanto. Vamo substituir “José” por “João” no primeiro_nome:\n\n\n'{\"primeiro_nome\": \"José\",\"sobrenome\": \"de Jesus Filho\"}' |> \n  jq('.primeiro_nome = \"João\"')\n\n{\n    \"primeiro_nome\": \"João\",\n    \"sobrenome\": \"de Jesus Filho\"\n}\n\nRepare que precisei colocar tudo entre aspas simples porque primeiro_nome é texto e, por isso, precisei usar aspas duplas em “João”.\nRemoção de valores\nA função del remove uma chave e seu correspondente valor:\n\n\n'{\"primeiro_nome\": \"José\",\"sobrenome\": \"de Jesus Filho\"}' |> \n  jq(\"del(.primeiro_nome)\")\n\n{\n    \"sobrenome\": \"de Jesus Filho\"\n}\n\nOperadores\nVocê pode usar operadores para somar números:\n\n\n'{\"a\": 3, \"b\": 5}' |> \njq(\".a + 3\")\n\n6\n\n\n\n'{\"a\": 3, \"b\": 5}' |> \njq(\".a * .b\")\n\n15\n\nPorém, quando se trata de texto:\n\n\n'{\"a\": \"arroz \", \"b\": \"e \", \"c\": \"feijão\"}' |> \n  jq(\".a + .b + .c\")\n\n\"arroz e feijão\"\n\nSomente as chaves\nChaves na ordem em que aparecem:\n\n\nx |> \n  jq(\". | keys_unsorted\")\n\n[\n    \"id\",\n    \"data\",\n    \"nome\",\n    \"cpf\",\n    \"disponivel\",\n    \"educacao\",\n    \"experiencia_profissional\"\n]\n\nChaves ordenadas alfabeticamente:\n\n\nx |> \n  jq(\". | keys\")\n\n[\n    \"cpf\",\n    \"data\",\n    \"disponivel\",\n    \"educacao\",\n    \"experiencia_profissional\",\n    \"id\",\n    \"nome\"\n]\n\nA chave existe?\n\n\nx |> \n   jq('has(\"nome\")')\n\ntrue\n\nOperadores map e map_values\nVocê usa map para operar em cada elemento e uma array:\n\n\n'[2,6,8]' |> \n  jq(\"map(. + 1)\")\n\n[\n    3,\n    7,\n    9\n]\n\nUsa map_values para objetos:\n\n\n'{\"a\": 2, \"b\": 3, \"c\": 4}' |> \n   jq(\"map_values(. *4)\")\n\n{\n    \"a\": 8,\n    \"b\": 12,\n    \"c\": 16\n}\n\nExpressões regulares\nSe você sabe expressões regulares, pode usar, mas ao usar “\\”, você tem de dar escape duas vezes:\nDetecta\nVerifica se no cpf há números:\n\n\nx |> \n  jq('.cpf | test(\"\\\\\\\\d\")')\n\ntrue\n\nVocê pode usar flags:\ng - Pesquisa global (encontrar todas as correspondências, não apenas a primeira)\ni - Não diferencia maiúsculas de minúsculas\nm - Modo de várias linhas ('.' ignora quebra de linhas)\nn - Ignora correspondências vazias\np - Ambos os modos s e m estão ativados\ns - Modo de linha única ('^' -> '\\A', '$' -> '\\Z')\nl - Encontre correspondências mais longas possíveis\nx - Formato regex estendido (ignora espaços em branco e comentários)\n\n\nx |> \n  jq('.nome.primeiro_nome | test(\"\",\"i\")')\n\n[\n    true,\n    false\n]\n\nCaptura\nVocê pode extrair texto com base em regex usando capture, mas você tem de informar a nova chave (key). Veja na sintaxe que eu começo com interrogação seguido da nova chave dentro de <…>:\n\n\n'{\"cep\": [\"05077-902\", \"02598154\"]}' |> \n   jq('.cep[] | capture(\"(?<codigo_postal>[0-9]+-?[0-9]+)\")')\n\n[\n    {\n        \"codigo_postal\": \"05077-902\"\n    },\n    {\n        \"codigo_postal\": \"02598154\"\n    }\n]\n\nEste tutorial apenas tocou no pacote jqr. Há uma uma multiplicidade de funções e recursos avançados os quais podem ser explorados sem sair do R. Aproveite para ler o manul: (https://stedolan.github.io/jq/manual)\n\n\n\n",
    "preview": {},
    "last_modified": "2022-12-26T12:40:04-03:00",
    "input_file": "json-no-rparte2.knit.md"
  },
  {
    "path": "posts/2022-10-15-objetos/",
    "title": "Objetos no R",
    "description": "Neste tutorial, mostramos o que são objetos no R e como\nmanuseá-los.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://github.com/jjesusfilho"
      }
    ],
    "date": "2022-10-15",
    "categories": [],
    "contents": "\nObjetos no R\nObjetos são valores nomeados. Quando falamos de valores no R, estamos\nnos referindo a algo que ocupa espaço na memória ram do cumputador. Pode\nser um número, um texto ou um conjunto de números ou de textos.\nEsses valores podem ser submetidos a operações matemáticas, no caso\nde números, ou transformados para gerar outros valores. Por exemplo,\n“Maria” pode se transformar em “MARIA”.\nCriando objetos\nPara criar objetos no R, você deve atribuir um valor a um nome.\nExemplos:\n\n\nnumero <- 2\n\nnome <- \"Maria\"\nnumero\n\n[1] 2\n\nnome\n\n[1] \"Maria\"\n\nPerceba que usamos o operador <- para atribuir o\nvalor a um nome. No R, você sempre usa esse operador para atribuir. Há\num outro operador, o =, que também pode ser usado, mas este\npossui usos mais específicos e falaremos dele no momento oportuno.\nDar nomes a objetos é como dar nome a filhos, alguns são proibidos,\noutros podem causar muitos problemas no futuro. Se você quiser chamar\nseu filho de “Esfiha”, o cartório irá recusar o registro. Se você usar\ncertos nomes, o R retornará um erro. Veja os exemplos abaixo, nomes têm\nde começar com letra e não podem ter operadores.\n3 <- 2 \n4m <- 4\n_x <- 'Mário' \nbem-te-vi <- \"pássaro\" ## O hífen é um operador matemático.\nEm todos os casos acima, o R recusará a criação do objeto. Assim\nmesmo, caso queira insistir na nomeação não convencional, o R aceitará\nse você usar o acento grave como demarcador:\n\n\n`3` <- 2 \n`3`\n\n[1] 2\n\nSe você fizer isso, as chances de encontrar problemas no futuro são\naltas.\nÉ aconselhável usar nomes sugestivos dos valores contidos neles, em\nletra minúscula e separados por _.\n\n\nidade <- c(25,29,40,57)\nendereco_residencial <- \"Rua José Mario Pereira, 43\"\n\n\nVetores\nQuando concatenamos um conjunto de valores da mesma natureza,\nchamamos esse objeto de vetor atômico. Exemplos:\n\n\nnumeros <- c(2,5,9,20)\nnumeros \n\n[1]  2  5  9 20\n\nnomes <- c(\"Maria\", \"Flávia\",\"Roberto\", \"Pedro\")\nnomes\n\n[1] \"Maria\"   \"Flávia\"  \"Roberto\" \"Pedro\"  \n\nObserve que para criar esses objetos, colocamos eles dentro da letra\nc com parênteses, que significa concatenar valores.\nOs vetores atômicos são assim chamados porque só podem conter um tipo\nde valor. Se você tentar concatenar texto com número, este último será\nconvertido em texto e você perderá a capacidade de realizar operações\nmatemáticas com ele.\n\n\nx <- c(\"Mário\", 3)\nx\n\n[1] \"Mário\" \"3\"    \n\nTipos e classes de objetos\nOs objetos podem ter tipos e classes. Os tipos correspondem à\nnatureza mesma do objeto, as classes dizem respeito ao\ncomportamento.\nInteiros\nVocê define um inteiro no R, colocando um L depois do número:\n\n\ninteiro <- 4L\ntypeof(inteiro)\n\n[1] \"integer\"\n\nNote que usamos a função typeof() para saber qual a\nnatureza do objeto.\nDouble\nDouble ou precisão dupla são formatos numéricos que ocupam 64 bits da\nmemória do computador, em contraste precisão singular, que ocupam 32.\nSão usados para referir a números com casas decimais, tanto racionais\nquanto irracionais.\n\n\nx <- 2.3\ny <- pi\n\ntypeof(x)\n\n[1] \"double\"\n\ntypeof(y)\n\n[1] \"double\"\n\nCharacter\nCharacter é o formato texto, ou string, em outras linguagens. Você\nusa ele para criar valores que não serão usados para operações\nmatématicas. Para criar character, você precisa usar aspas simples ou\nduplas.\n\n\nnome <- \"Flaviana\"\ncpf <- \"123.456.768-10\"\n\n\nSe você colocar aspas nos números, eles serão tratados como\ncharacteres. Se você tentar realizar operações, o R retornará um\nerro.\n\n\nn1 <- \"2\"\nn2 <- \"3\"\n\nn1 + n2\n\nError in n1 + n2: argumento não-numérico para operador binário\n\nMesmos tipos,\ndiferentes comportamentos (classes)\nEm programação, além dos tipos, existe uma outro conceito chamado\nclasse, o qual diz respeito ao comportamento dos objetos. Os tipos\nbásicos que vimos acima, podem ser representados em diferentes classes.\nDuas delas são especialmente importantes: datas e fatores\nDatas\nDatas são do tipo numérico (double), mas visualizadas no seguinte\nformato: “aaaa-mm-dd”, ou seja, mês, dia, ano. Esse formato segue o\npadrão internacional ISO-8601. O ano vem sempre com quatro dígitos e a\nordem segue do maior para o menor.\nPara criar datas, precisamos de uma função do R chamas\nas.Date().\n\n\nd1 <- as.Date(\"2022-02-15\")\nd1\n\n[1] \"2022-02-15\"\n\nVeja que ela foi impressa entre aspas, mas na verdade ela é um\ndouble:\n\n\ntypeof(d1)\n\n[1] \"double\"\n\nIsso ocorre porque, dessa forma, você pode realizar operações\nmatemáticas com datas:\n\n\nd1 <- as.Date(\"2022-02-15\")\nd2 <- as.Date(\"2022-03-16\")\n\nd2 - d1\n\nTime difference of 29 days\n\nComo a data é um número, é possível convertê-la para o formato\ndouble, usando a função as.numeric():\n\n\nas.numeric(d1)\n\n[1] 19038\n\nEsse número, 19038, é o número de dias desde 01 de janeiro de 1970.\nDatas anteriores a esta data são representadas negativamente:\n\n\nn3 <- as.Date(\"1950-04-03\")\nas.numeric(n3)\n\n[1] -7213\n\nFatores\nSuponha que você realize uma pesquisa entre seus colegas de trabalho\ncom perguntas como: Qual o seu primeiro nome e qual a sua religião e\nobtenha as seguintes respostas:\n\n\nprimeiro_nome <- c(\"Fábio\",\"Maria\",\"Maria\",\"José\", \"Catarina\",\"José\")\n\nprimeiro_nome\n\n[1] \"Fábio\"    \"Maria\"    \"Maria\"    \"José\"     \"Catarina\" \"José\"    \n\n\n\nreligiao <- c(\"cristão\",\"espírita\",\"budista\", \"cristão\",\"espírita\", \"cristão\")\nreligiao\n\n[1] \"cristão\"  \"espírita\" \"budista\"  \"cristão\"  \"espírita\" \"cristão\" \n\nParece natural que alguns nomes e algumas religões vão se repetir nas\nrespostas. Quando isso acontece, é preferível pedir ao R para armazenar\nessas respostas como números e associar etiquetas a esses números,\ncorrespondentes às respostas. Esse tipo de dados é chamado de categórico\nporque os possíveis valores que ele assume são conhecidos e\nlimitados.\nExiste uma função no R própria para tratar de dados categóricos.\n\n\nprimeiro_nome <- factor(primeiro_nome)\nprimeiro_nome\n\n[1] Fábio    Maria    Maria    José     Catarina José    \nLevels: Catarina Fábio José Maria\n\n\n\nreligiao <- factor(religiao)\nreligiao\n\n[1] cristão  espírita budista  cristão  espírita cristão \nLevels: budista cristão espírita\n\nAo chamar o função factor(), o R associa cada categoria\na um número e etiqueta cada uma delas com os nomes originais. Essas\netiquetas são atributos chamados níveis (levels). Note que os\nlevels estão em ordem alfabética e são únicos.\nReligião agora é do tipo numérico, mas de classe fator. Sua natureza\né numérica, mas seu comportamento é de categoria. Você visualiza como se\nfosse texto, mas, na verdade, é um número.\nSe você converter o fator para inteiro, ele retorna os números\ncorrespondentes.\n\n\nas.integer(religiao)\n\n[1] 2 3 1 2 3 2\n\nHá duas vantagens em usar fatores. A primeira é que os dados serão\narmazenados como inteiros, o que reduz o uso da memória. A segunda é que\nanálises estatísticas realizam operações com matrizes numéricas.\nMatrizes\nMatrizes são vetores atômicos com duas dimensões. Vamos criar um\nvetor de quinze números sequenciais. No R, você faz isso usando : (dois\npontos) entre o primeiro e o último:\n\n\nx <- 1:15\nx\n\n [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n\nAgora vamos converter para uma matriz de duas três colunas e cinco\nlinhas:\n\n\nmatrix(x, nrow = 5) # É suficiente informar o número de linhas\n\n     [,1] [,2] [,3]\n[1,]    1    6   11\n[2,]    2    7   12\n[3,]    3    8   13\n[4,]    4    9   14\n[5,]    5   10   15\n\nVocê pode criar uma matriz de textos também. Vamos criar um vetor com\nas dezesseis primeiras letras do alfabeto. O R já tem um objeto chamado\nletters, vamos simplesmente obter um subconjunto delas. Para tanto,\nusamos colchetes.\n\n\nx <- letters[1:16]\nx\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\"\n\n\n\nmatrix(x, ncol = 4)\n\n     [,1] [,2] [,3] [,4]\n[1,] \"a\"  \"e\"  \"i\"  \"m\" \n[2,] \"b\"  \"f\"  \"j\"  \"n\" \n[3,] \"c\"  \"g\"  \"k\"  \"o\" \n[4,] \"d\"  \"h\"  \"l\"  \"p\" \n\nUma característica das matrizes é que elas são atômicas, i.e, todos\nos elementos têm de ser do mesmo tipo.\nDataframes\nSemelhante às planilhas do excel ou as tabelas de SQL, o R possui\ndataframes, que são nada menos que um emparelhamento de vetores do mesmo\ntamanho.\nPara criar dataframes, você usa a função data.frame().\nVamos criar um dataframe com os nomes e respectivas religiões acima\ncriados.\n\n\ndf <- data.frame(primeir_nome = primeiro_nome,\n                 religiao = religiao)\ndf\n\n  primeir_nome religiao\n1        Fábio  cristão\n2        Maria espírita\n3        Maria  budista\n4         José  cristão\n5     Catarina espírita\n6         José  cristão\n\nHá uma classe especial de dataframe chamada tibble, que é\npraticamente idêntica a dataframe, mas um pouco mais segura para\noperar.\nListas\nPor fim, o R possui um tipo de objeto chamado list.\nListas podem conter todos os demais tipois de objetos. Elas geralmente\nsão usados para conter objetos de diferentes tipos e tamanhos. Podemos\ncriar uma lista com alguns dos objetos já criados.\n\n\nlista <- list(religiao, x, df)\nlista\n\n[[1]]\n[1] cristão  espírita budista  cristão  espírita cristão \nLevels: budista cristão espírita\n\n[[2]]\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\"\n\n[[3]]\n  primeir_nome religiao\n1        Fábio  cristão\n2        Maria espírita\n3        Maria  budista\n4         José  cristão\n5     Catarina espírita\n6         José  cristão\n\nOs dataframes são, a rigor, listas também, em que cada coluna\nconstitui um elemento. Eles são listas com a classe dataframe. Isso\nsignifica que o comportamento dos dataframes será diferente das demais\nlistas. Vamos perguntar ao R qual o tipo e qual a classe do objeto df\nacima criado.\n\n\ntypeof(df)\n\n[1] \"list\"\n\n\n\nclass(df)\n\n[1] \"data.frame\"\n\nIndexação e subconjuntos\nDiferentemente de outras linguagens, como Python, que começam a\ncontar do zero, o R começa a contar os elementos de um vetor ou de uma\nlista, a partir do 1 (um) até o tamanho do vetor.\nPara extrair um elemento de um vetor ou de uma lista, use colchetes\ncom o índice. Por exemplo, se quiser obter a segunda letra do\nalfabeto:\n\n\nletters[2]\n\n[1] \"b\"\n\nPara obter da segunda até a quarta letra:\n\n\nletters[2:4]\n\n[1] \"b\" \"c\" \"d\"\n\nSe você quiser excluir uma delas, use o sinal de menos na frente do\nnúmero:\n\n\nletters[-1]\n\n [1] \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\"\n[17] \"r\" \"s\" \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\nPor outro lado, se você quiser obter valores contando do final, use a\nfunção length() dentro dos colchetes:\n\n\nletters[length(letters)]\n\n[1] \"z\"\n\nHá também uma função chamada tail(), que é mais lenta,\nmas é mais flexível:\n\n\ntail(letters,1)\n\n[1] \"z\"\n\nSe quiser obter os três últimos valores:\n\n\ntail(letters,3)\n\n[1] \"x\" \"y\" \"z\"\n\nEssas mesmas regras valem para listas em geral. Para dataframes, há\num pacote chamado dplyr(), o qual possui funções próprias\npara isso.\n\n\n\n",
    "preview": {},
    "last_modified": "2022-10-17T06:47:25-03:00",
    "input_file": "objetos.knit.md"
  },
  {
    "path": "posts/2022-10-06-sobrevivencia/",
    "title": "O tempo do processo judicial",
    "description": "Como calculo a duração do processo? Neste tutorial, introduzo uma metodologia própria para estimar o tempo desde a instauração até a apreciação do pedido. A análise de sobrevivência ou análise de duração compreende várias técnicas estatísticas para estimar a duração do processo.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://github.com/jjesusfilho"
      }
    ],
    "date": "2022-10-06",
    "categories": [],
    "contents": "\n\n\n\nA jurimetria inclui uma variedade de temas, métodos e técnicas\naplicadas ao direito. Duas delas, porém, sobressaem dentre as demais. O\ninteresse no desfecho processual e o interesse no tempo do processo.\nNeste tutorial, abordaremos o segundo, que é o tempo do processo.\nPara análise do tempo do processo, há uma técnica conhecida como\nanálise de sobrevivência, desenvolvida no âmbito da pesquisa em saúde,\nmas que é muito apropriada para entender a duração do processo desde o\npedido até sua apreciação ou qualquer outro ato processual de interesse.\nComo estamos trabalhando no âmbito do direito, de agora em diante,\nfalaremos em análise de duração, em vez de sobrevivência.\nA análise de duração é também conhecida como tempo para o evento\n(time-to-event). Basicamente, ela é composta por quatro elementos.\nSujeito. No presente caso, o processo judicial.\nData da exposição. No presente caso, a data da distribuição da ação,\nda instauração do inquérito ou do recurso.\nData do evento. Momento do ato processual.\nDuração. Tempo entre a data da exposição e a data do evento.\nO evento em si mesmo não é objeto da análise. Embora, como veremos\nadiante, a natureza do ato processual pode afetar significativamente o\ntempo do processo.\nExemplos\nEmpresa (sujeito) inicia atividade (exposição) até (duração)\nfalência (data do evento);\nCasal (sujeito) contrai matrimônio (exposição) até (duração) o\ndivórcio (data do evento).\nPessoa (sujeito) é diagnosticada com câncer (exposição) até\n(duração) sua morte (data do evento).\nProcesso judicial (sujeito) é distribuído (exposição) até (tempo)\nsua extinção (data do evento).\nConceitos chave\nAntes de mostrar como rodar uma análise de duração, é preciso ter\nfamiliaridade com alguns conceitos chave para este tipo de análise.\nCensura\nUm aspecto chave na análise de duração é a censura de dados. Quando\nnão se conhece o tempo até o evento para um indivíduo, diz-se que esse\ndado é censurado. Há três tipos de dados censurados.\nCensura à esquerda: Tj < x: O tempo para o evento é menor do\nque um valor particular. Esta é a situação em que o evento ocorre antes\ndo momento da exposição. Por exemplo, quando há arquivamento de\ninquérito, termo de ajustamento de conduta ou acordo sem que processo\ntenha sido instaurado.\nCensura intervalar: x1 < Tj < x2 Sabemos que o tempo para o\nevento está entre dois momentos, mas não sabemos quando isso ocorreu.\nPor exemplo, sabemos quando a ação foi distribuída e sabemos quando ela\nfoi julgada, mas não sabemos quando ocorreu a pronúncia, quando ocorreu\na apreciação do pedido de antecipação de tutela.\nCensura à direita: Tj > x: O tempo para um evento é maior que\num valor particular. Esta é a situação mais comum. Sabemos quando o\nprocesso foi instaurado, mas não quando foi julgado o mérito ou\napreciado o pedido de liminar, especialmente porque no momento de\ninteresse esta informação não estava disponível. Exemplo, ao coletar\ndados sobre mandado de segurança, verificamos que o pedido de liminar\nnão foi apreciado um mês após sua judicialização.\nA análise de duração leva em conta a censura de dados. Você verá mais\nadiante que incluiremos uma coluna em nossa tabela informando se o\nevento ocorreu ou se foi censurado. O tempo para o evento é sempre o\nmenor valor entre o tempo de censura e o tempo para o evento.\nFunções de sobrevivência e\nde risco\nOutro conceito importante é a probabilidade de que um processo\njudicial (sujeito) vai durar para além de um determinado tempo,\ncalculada por meio da função de sobrevivência ou de duração \\(S(t)\\). Se formos adaptar a linguagem para\no direito processual, podemos chamá-la de função de pendência e a\ncorrespondente probabilidade de pendência, vez que se estima a\nprobabilidade de que um pedido se encontra pendente num determinado\nmomento.\nAlém dela, existe a função de risco (hazard function) \\(h(t)\\), a qual calcula a probabilidade de\nque um ato processual foi realizado no tempo t.\nNote que a primeira foca na probabilidade de não ter ocorrido o\nevento, enquanto que a segunda, de ter ocorrido.\nMétodo Kaplan-Meier (KM)\nKaplan-meier é uma análise não paramétrica para estimar a\nprobabilidade de duração S(t). Não paramétrica significa que estimamos\nparâmetros e não assumimos que os valores seguem uma distribuição\nprobabilística específica, tal como a distribuição normal.\nPor este método, a função de duração S(t) é calculada da seguinte\nforma:\n\\[ S(t_i) = S(t_i-1)(1 -\n\\frac{d_i}{n_i})\\]\nEm que:\n\\(S(t_i - 1)\\)= Probabilidade do\npedido estar tramitando no tempo \\(t_i -\n1\\).\\(n_i\\) = Número de pedidos processuais\ntramitando imediatamente antes de \\(t_i\\).\\(d_i\\) = Número de eventos no tempo\n\\(t_i\\).\\(t_0 = 0, S(0) = 1\\)\nA função de duração \\(S(t)\\) apenas\naltera o valor no tempo de cada evento. É possível calcular o erro\npadrão e o intervalo de confiança da taxa de sobrevivência.\nKaplan-Meier permite também avaliar como grupos, por exemplo,\ntribunais ou varas diferem diferem no tempo de processamento.\nIgualmente, permite verificar como cada um dos grupos experimenta as\ncurvas de duração. Mais adiante, mostraremos como criar a curva\nKaplan-Meier.\nUma limitação do método Kaplan-Meier é que ele permite a inclusão de\nvariáveis categóricas apenas. Para incluir variáveis contínuas, temos de\nrecorrer ao risco proporcional \\(h(t)\\)\nde Cox. No presente tutorial, não abordaremos o Risco Proporcional de\nCox porque no exemplo oferecido não temos variáveis contínuas e, para\nnão sobrecarregar muito o leitor, trataremos do tema e outro\ntutorial.\nTempo do Habeas Corpus\nPara este tutorial, optamos por baixar pedidos de habeas corpus\nperante o Tribunal de Justiça de São Paulo contra atos de magistrados de\nprimeira instância. Inicialmente, pensamos em analisar o tempo até a\napreciação do pedido de liminar. No entanto, nem todos os HCs têm pedido\nde antecipação cautelar, muitas decisões concedem HC liminarmente\nindependentemente de haver pedido de antecipação. Muitos HCs, mesmo com\npedido de liminar, diferem o processamento até a apreciação de mérito.\nDessa forma, optamos por observar o tempo entre a entrada no TJSP até a\napreciação do mérito, independentemente se este foi decidido\nliminarmente ou não.\nPara esta análise, baixamos 3174\npedidos de HCs. Basicamente o que fizemos foi usar a função\ncnj_sequencial do pacote JurisMiner para criar\nduas sequências de números do CNJ. Uma que começa com 20, outra que\ncomeça com 00. Fizemos isso porque notamos que havia dois padrões de\nnumeração. O primeiro, que começa com 20, corresponde a habeas corpus\nimpetrados eletronicamente, geralmente por advogados, especialmente a\nDefensoria Pública. O segundo, que começa com 00, corresponde a HCs\nimpetrados pelos próprios pacientes ou seus familiares, geralmente\npresos com pedidos no âmbito da execução penal.\nColeta dos dados\nAdicionei esta seção, somente para documentação do procedimento de\ncoleta. Você pode saltá-la e ir diretamente para a análise. A base\nutilizada se encontra aqui.\nVeja abaixo como eu fiz. Primeiramente, criei um diretório chamado\ncpopsg (Consulta de julgados de segundo grau). Depois criei cada uma das\nsequências e coloquei para baixar os processos.\nNote que, antes de usar essas funções, você tem de instalar os\npacotes JurisMiner\ne tjsp:\nremotes::install_github(\"courtsbr/JurisMiner\")\nremotes::install_github(\"jjesusfilho/tjsp\")\nVamos carregar os pacotes acima e também o tidyverse, pois este é\nnossa principal ferramenta de ciência de dados.\n\n\nlibrary(tidyverse)\nlibrary(JurisMiner)\nlibrary(tjsp)\n\n\ndir.create(\"cposg\")\n\nsequencia <- cnj_sequencial(inicio = 2000001, ## início da sequência\n                                           fim = 2010000, ## fim da sequência\n                                           ano = 2022,  ## ano do processo\n                                           segmento = 8, ## Justiça estadual\n                                           tribunal = 26, ## TJSP\n                                           distribuidor = 0000 ## Segunda instância.\n                                           ) \n\ntjsp_baixar_cposg(sequencia, \"cposg\")\n\nsequencia <- cnj_sequencial(inicio = 0000001,\n                                           fim = 0010000,\n                                           ano = 2022, \n                                           segmento = 8,\n                                           tribunal = 26,\n                                           distribuidor = 0000)\n                                           \ntjsp_baixar_cposg(sequencia, diretorio = \"cposg\")\nDepois de baixar os htmls com os metadados processuais, a próxima\netapa é ler os dados básicos, a movimentação e a decisão. O pacote tjsp possui funções para\nisso.\narquivos <- list.files(\"cposg\", full. names = TRUE) ## Lista o caminho de cada arquivo\n\ndados <- tjsp_ler_dados_cposg(arquivos) ## importa para o R os dados básicos\nEsses dados são todos os 20 mil primeiros processos instaurados na\nsegunda instância do TJSP. Eles são, via de regra, ações autônomas.\nAntes de lermos a movimentação processual, bem como, as decisões,\nprecisamos filtrar para somente aquele que são habeas corpus\ncriminais.\ndados <- dados |> \n     filter(classe == \"Habeas Corpus Criminal\") ## Mantêm somente os habeas corpus.\nFeito isso, vamos criar uma tabela com os arquivos e, a partir dela,\ncriar uma coluna processo, extrair do nome do arquivo o número do\nprocesso para, então, filtrar somente aqueles que são HCs.\ntb <- tibble(arquivo = arquivos) |> ## Coloca o vetor de arquivos numa coluna de tibble\n      mutate(processo = str_extract(arquivo,\"\\\\d{20}\")) ## extrai os números dos processos.\n\ntb <- tb |> \n     semi_join(dados, by = \"processo\") ## Mantêm os arquivos cujos processos são HCs.\nAgora podemos ler somente as decisões e movimentações dos processos\nque são HC.\ndispositivos <- tjsp_ler_dispositivo(tb$arquivo)\n\nmovimentacao <- tjsp_ler_movimentacao(tb$arquivo)\nVamos visualizar a estrutura dos dados.\ndados |> \n sample_n(10) |> \n glimpse()\n\nRows: 10\nColumns: 21\n$ processo           <chr> \"00006152420228260000\", \"0003933152022826…\n$ digital            <lgl> TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE,…\n$ situacao           <chr> \"Arquivado administrativamente\", \"Arquiva…\n$ cd_processo        <chr> \"RI006Q23O0000\", \"RI006R09C0000\", \"RI006Q…\n$ v1                 <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA\n$ area               <chr> \"Criminal\", \"Criminal\", \"Criminal\", \"Crim…\n$ assunto            <chr> \"DIREITO PENAL - Crimes contra o Patrimôn…\n$ classe             <chr> \" Habeas Corpus Criminal\\n\", \" Petição Cr…\n$ distribuicao       <chr> NA, \" \\n\", \" \\n\", NA, \" \\n\", \" \\n\", NA, \"…\n$ orgao_julgador     <chr> \" 9ª Câmara de Direito Criminal\\n\", NA, N…\n$ origem             <chr> \"Comarca de Marília / Foro de Marília / V…\n$ outros_numeros     <chr> \"\\n                            \\n        …\n$ processo_principal <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA\n$ recebido_em        <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA\n$ recurso            <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA\n$ relator            <chr> \"CÉSAR AUGUSTO ANDRADE DE CASTRO\", NA, NA…\n$ revisor            <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA\n$ secao              <chr> \" Direito Criminal\\n\", \" Direito Criminal…\n$ ultima_carga       <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA\n$ valor_da_acao      <chr> NA, NA, NA, \"1.200,00\", NA, NA, \"1.000,00…\n$ volume_apenso      <chr> \"1 / 0\", \"1 / 0\", \"1 / 0\", \"1 / 0\", \"1 / …\n\nDesses dados, nós preservaremos somente o número do processo e o\nórgão julgador. Além disso, iremos manter somente as câmaras de direito\ncriminal, ajustar sua descrição e convertê-las em fator ordenado.\nIgualmente, iremos criar uma nova coluna com a informação de que o\nprocesso é originalmente físico, protocolado pelo preso, ou eletrônico\ndesde o início. Para tanto, basta verificar o início do processo. Se\ncomeça com 20 é totalmente eletrônico, com 00 é inicialmente físico, ou\nseja, o pedido foi possivelmente escrito a mão por um pessoa privada de\nliberdade.\nNão iremos usar a informação sobre o crime, mas assim mesmo, vamos\nreter a informação sobre o crime do assunto. Os casos em que não há\ninformação do crime parecem ser execução penal. Vamos converter esses\ncasos, sem informação sobre o crime, em execução penal.\nordenar_camaras <- function(x){\nstringr::str_remove_all(x, \"(\\\\s|[:lower:]+)\") %>% factor(.,levels = stringr::str_sort(unique(.),\nnumeric = T))\n}\n\ndados <- dados |> \n     mutate(crime = str_extract(assunto, \"(?<=-)[^-]+$\"), .after = assunto) ## extrai tudo que depois do último hífen.\n     mutate(crime = str_squish(crime)) |> ## remove espaços extra.\n     mutate(crime = ifelse(assunto == \"DIREITO PENAL\", \"Execução penal\", crime)) ## Se houver só a expressão DIREITO PENAL penal no assunto, converte o crime em Execução penal.\n      select(processo, orgao_julgador, crime) |> \n      mutate(camara = ordenar_camaras(orgao_julgador)) |> \n      mutate(fisico = ifelse(str_detect(processo, \"^0\"), \"sim\", \"não\"))\nA base dispositivos possui três colunas, processo, data e\ndispositivo. Além disso, nem todos os processos contêm a informação da\ndecisão. Na verdade, ao examinar a base é possível saber que houve\ndecisão e é até possível extraí-la da movimentação, mas vamos manter sem\nessa informação por razões pedagógicas a fim de ilustrar como dados\ncensurados são incorporados na análise.\nNo código abaixo, usamos a função tjsp_classificar_writ\npara extrair do dispositivo o teor da decisão. Não usaremos essa\ninformação, mas manteremos na base por sua eventual utilidade.\nIgualmente, extraímos a informação de que a concessão foi em caráter\nliminar ou não.\ndispositivos <- dispositivos |> \n           mutate(decisao = tjsp_classificar_writ(dispositivo)) |> \n          mutate(liminar = case_when(\n         str_detect(dispositivo,\"(?i)\\\\blimin\") ~ \"sim\",\n         TRUE ~ \"não\"\n       ))\nVamos extrair da movimentação a primeira movimentação de cada\nprocesso, que pode ser interpretada como a distribuição do HC.\n\ndistribuicao <- movimentacao |>\n           group_by(processo) |>\n           filter(data== min(data)) |>\n           slice(1) |> \n           select(processo, data_distribuicao = data)\nPor fim, vamos juntar essas três bases e criar uma nova coluna\nchamada duração, que é a diferença entre a data da distribuição e a data\nda decisão. O pacote tjsp tem uma função chamada lapso, que serve para\nisso. Iremos colocar a duração em dias porque a movimentação não informa\na hora. Iremos também adicionar uma coluna informando o status da\ninformação, se foi censurada terá valor 0, se não, valor 1.\nbase <- dispositivos |> \n        select(processo, liminar, data_decisao = data, decisao) |> \n        inner_join(dados, by = \"processo\") |> \n        inner_join(dispositivos, by = \"processo\") |> \n        mutate(duracao = lapso(inicio = data_distribuicao, \n                               fim = data_decisao, \n                               unidade = \"dia\")\n                               ) |> \n       mutate(status = ifelse(is.na(duracao),0, 1))\nPor fim, vamos ordenar as colunas e converter as variáveis\nindependentes em fatores\nbase <- base |> \nselect(processo, duracao, status, data_distribuicao, data_decisao,  status, camara,crime, liminar, fisico, decisao) |> \nmutate(across(crime:decisao, as.factor))\nAnálise\nEstamos em condições de aplicar a análise de duração. Antes, porém,\nvamos visualizar os dados. São 3174 pedidos julgados. No entanto, há 587\ncasos censurados porque “não sabemos” quando foram decididos. Sabemos,\nporém que foram julgados porque todos foram extintos.\n\n\nglimpse(base)\n\nRows: 3,174\nColumns: 10\n$ processo          <chr> \"00100009320228260000\", \"00099948620228260…\n$ duracao           <dbl> 28, 30, 30, 1000, 44, 9, 65, 20, 14, 61, 7…\n$ status            <dbl> 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, …\n$ data_distribuicao <date> 2022-03-30, 2022-03-30, 2022-03-30, 2022-…\n$ data_decisao      <date> 2022-04-27, 2022-04-29, 2022-04-29, NA, 2…\n$ camara            <fct> 15CDC, 10CDC, 13CDC, 14CDC, 2CDC, 7CDC, 12…\n$ crime             <fct> \"Furto Qualificado\", \"Receptação Qualifica…\n$ liminar           <fct> não, não, não, não, não, não, não, não, si…\n$ formato           <fct> físico, físico, físico, físico, físico, fí…\n$ decisao           <fct> prejudicado/extinto, denegado, não conheci…\n\nPara a análise, iremos usar dois pacotes, o survival que\njá vem instalado com o R e survminer, que serve para gerar\ngráficos usando o ggplot2.\nInstale o surviminer:\ninstall.packages(\"survminer\")\nCarregue os dois pacotes:\n\n\nlibrary(survival)\nlibrary(survminer)\n\n\nDo pacote survival, usaremos duas funções, Surv e survfit. A primeira\ncria um objeto “survival” com informações sobre o tempo, o status e o\ntipo de censura. A segunda roda o modelo Kaplan-Meier com seus\nrespectivos estimadores.\nInicialmente, vamos rodar o modelo sem as variáveis categóricas. Note\nque eu crio, com a função Surv o objeto. Nela eu coloquei o tempo\n(duração) e o status. Além disso, está subentendido o tipo de censura,\nque é à direita.\n\n\nkm_fit <- survfit(Surv(duracao, status) ~ 1, data = base)\n\n\nOs resultados mostram que de 3.174 pedidos, tivemos 2.604 decisões\nconhecidas. As demais foram censuradas. A mediana é de 40 dias. A\nmediana é mais apropriada que a média em análise de duração porque a\ndistribuição das decisões é mais concentrada nos primeiros momentos, com\npoucos casos, mas importantes, com alta duração.\n\n\nkm_fit\n\nCall: survfit(formula = Surv(duracao, status) ~ 1, data = base)\n\n        n events median 0.95LCL 0.95UCL\n[1,] 3174   2604     40      39      42\n\nPara visualizar os resultados em mais detalhes, vamos usar a função\nsurv_summary do pacote survminer. Vamos também\nrenomear as colunas para nomes mais amigáveis em termos de\ncompreensão.\nMostraremos somente as 15 primeiras linhas e as 11 últimas para caber\nna página.\n\n\nsumario <- surv_summary(km_fit) |> \n        setNames(c(\"tempo_em_dias\",\"pedidos_pendentes\",\"pedidos_decididos\",\n        \"n_censurados\",\"prob_duracao\",\"erro\",\"ic_inferior\",\"ic_superior\")) |> \n   slice(c(1:15, 120:130))\n\nsumario\n\n\n\ntempo_em_dias\npedidos_pendentes\npedidos_decididos\nn_censurados\nprob_duracao\nerro\nic_inferior\nic_superior\n2\n3174\n3\n0\n0.9990548\n0.0005460\n1.0000000\n0.9979863\n3\n3171\n8\n0\n0.9965343\n0.0010468\n0.9985809\n0.9944920\n4\n3163\n4\n0\n0.9952741\n0.0012231\n0.9976629\n0.9928910\n5\n3159\n8\n0\n0.9927536\n0.0015165\n0.9957087\n0.9898073\n6\n3151\n18\n0\n0.9870825\n0.0020305\n0.9910187\n0.9831620\n7\n3133\n31\n0\n0.9773157\n0.0027042\n0.9825094\n0.9721495\n8\n3102\n34\n0\n0.9666037\n0.0032993\n0.9728745\n0.9603733\n9\n3068\n31\n0\n0.9568368\n0.0037699\n0.9639330\n0.9497928\n10\n3037\n23\n0\n0.9495904\n0.0040896\n0.9572325\n0.9420094\n11\n3014\n22\n0\n0.9426591\n0.0043778\n0.9507821\n0.9346055\n12\n2992\n14\n0\n0.9382483\n0.0045537\n0.9466597\n0.9299116\n13\n2978\n35\n0\n0.9272212\n0.0049729\n0.9363027\n0.9182278\n14\n2943\n32\n0\n0.9171393\n0.0053352\n0.9267800\n0.9075988\n15\n2911\n26\n0\n0.9089477\n0.0056179\n0.9190113\n0.8989943\n16\n2885\n38\n0\n0.8969754\n0.0060156\n0.9076136\n0.8864619\n144\n581\n1\n0\n0.1827347\n0.0375377\n0.1966859\n0.1697731\n148\n580\n1\n0\n0.1824197\n0.0375773\n0.1963620\n0.1694672\n152\n579\n1\n0\n0.1821046\n0.0376171\n0.1960382\n0.1691614\n161\n578\n1\n0\n0.1817895\n0.0376569\n0.1957143\n0.1688555\n167\n577\n1\n0\n0.1814745\n0.0376968\n0.1953904\n0.1685497\n168\n576\n1\n0\n0.1811594\n0.0377369\n0.1950665\n0.1682439\n173\n575\n1\n0\n0.1808444\n0.0377770\n0.1947425\n0.1679381\n190\n574\n1\n0\n0.1805293\n0.0378172\n0.1944186\n0.1676323\n227\n573\n1\n0\n0.1802142\n0.0378575\n0.1940946\n0.1673265\n234\n572\n1\n0\n0.1798992\n0.0378979\n0.1937706\n0.1670207\n237\n571\n1\n0\n0.1795841\n0.0379385\n0.1934466\n0.1667150\n\nVeja que o primeiro tempo é dois dias, ou seja, depois de dois dias,\nhavia 3174 casos, sendo que três casos foram julgados. Depois de três\ndias, oito casos foram julgados. A tabela também mostra o número de\npedidos pendentes depois de um certo número de dias. Também mostra a\nprobabilidade de pendência, ou seja, a probabilidade de o pedido não ter\nsido apreciado a cada momento.\nA curva de Kaplan-Meier é ilustrativa, veja abaixo. Limitamos no\ngráfico para 180 dias e colocamos intervalos de dez dias para facilitar\na visualização.\n\n\nggsurvplot(km_fit,\n           xlim = c(0,180),\n           break.time.by = 10,\n           ylab = \"Probabilidade de pendência\",\n           xlab = \"Tempo em dias\",\n           legend.title = \"Tempo para apreciar pedidos de habeas corpus\",\n           ggtheme = theme_light()\n           )\n\n\n\nVeja que a curva mostra a probabilidade de pendência ou duração ao\nlongo do tempo. Isto é, no tempo zero, 100% está pendente. Conforme o\ntempo passa, a taxa de pendência vai caindo.\nDuração por câmara\nVamos agora observar como ficam os tempos quando condicionamos por\ncâmara de direito criminal.\n\n\nkm_fit <- survfit(Surv(duracao, status) ~ camara, data = base)\n\n\nVocê pode visualizar os resultados com\nsurv_summary(km_fit). Aqui iremos apenas gerar os gráficos\ndas curvas de Kaplan-Meier para cada câmara de direito criminal.\n\n\ncurva <- ggsurvplot(km_fit,\n                    data = base,\n                    break.time.by = 15 ,\n                    xlim = c(0,120),\n                    ylab = \"Probabilidade de pendência\",\n                    xlab = \"Tempo em dias\",\n                    ggtheme = theme_light()\n                    )\n\n\najusta_etiqueta <- function(x) stringr::str_remove(x, \"camara=\")\n\ncurva$plot +\n  facet_wrap(~strata, labeller = as_labeller(ajusta_etiqueta)) +\n  theme(legend.position=\"none\")\n\n\n\nAs curvas sugerem diferenças entre as câmaras criminais. Algumas,\ncomo a quinta e a oitava câmaras decidem um número relevante de casos\nlogo nos primeiros dias. Por su vez, a 10ª e a 15ª demoram um pouco\nmais, mas suas curvas mostram uma redução relevante de casos depois de\num certo período.\nTeste Logrank\nPara saber se essas curvas são realmente diferentes, há um teste\nchamado logrank. Por meio dele, verifica-se de os grupos (câmaras de\ndireito criminal) experimentam diferenças nas curvas, i.e., dado um\nmomento, e.g., 5 dias após o pedido, o número de decisões é o mesmo para\ncada um, ou difere significativamente. Basicamente o teste compara o\nnúmero de decisões observadas e o número de decisões esperadas para cada\nmomento e apresenta a soma deles. O teste logrank adotado pelo R é uma\naproximação ao teste do Chi Quadrado. Se você não tem familiaridade com\no teste do Chi Quadrado, esse vídeo pode\nlhe ajudar.\nPara realizar o teste, há uma função específica:\n\n\nsurv_diff <- survdiff(Surv(duracao, status) ~ camara, data = base)\nsurv_diff\n\nCall:\nsurvdiff(formula = Surv(duracao, status) ~ camara, data = base)\n\n               N Observed Expected (O-E)^2/E (O-E)^2/V\ncamara=1CDC  191      162    149.2   1.09465   1.18900\ncamara=2CDC  165      144    106.4  13.26440  14.16525\ncamara=3CDC  192      142    196.8  15.26736  16.93715\ncamara=4CDC  225      187    231.1   8.40432   9.45539\ncamara=5CDC  164      149     98.6  25.74522  27.39508\ncamara=6CDC  231      142    200.6  17.11896  19.10198\ncamara=7CDC  216      191    183.1   0.34045   0.37579\ncamara=8CDC  306      290    210.2  30.26589  33.76487\ncamara=9CDC  190      190    105.4  67.79794  72.79231\ncamara=10CDC 133      110    128.7   2.71341   2.92378\ncamara=11CDC 190      176    115.6  31.59349  33.88838\ncamara=12CDC 153      138    137.6   0.00136   0.00148\ncamara=13CDC 186      126    178.6  15.48205  17.02984\ncamara=14CDC 204      143    194.1  13.45849  14.89480\ncamara=15CDC 224      157    204.1  10.86918  12.08055\ncamara=16CDC 204      157    163.8   0.28635   0.31276\n\n Chisq= 264  on 15 degrees of freedom, p= <2e-16 \n\nComo se pode observar dos resultados, há diferenças significativas\nentre as câmaras, p-valor < 0.05. Algumas decidiram mais hebeas\ncorpus do que o esperado a cada momento, outras ficaram aquém do\nesperado.\nDuração com múltiplas\nvariáveis.\nVamos agora incluir o formato entre as variáveis condicionantes do\ntempo para julgar um HC e ver os resultados grafivamente.\n\n\nkm_fit <- survfit(Surv(duracao, status) ~ camara + formato, data = base)\n\ncurva <- ggsurvplot(km_fit,\n                    data = base,\n                    break.time.by = 20 ,\n                    xlim = c(0,120),\n                    ylab = \"Probabilidade de pendência\",\n                    xlab = \"Tempo em dias\",\n                    ggtheme = theme_light()\n                    )\n\n\nremove_nome <- function(x) stringr::str_remove_all(x, \"\\\\w+=\")\n\ncurva$plot +\n  facet_wrap(~strata, labeller = as_labeller(remove_nome))+\n  theme(legend.position=\"none\")\n\n\n\nQuando olhamos para algumas câmaras, como a 13ª e a 15ª, os processos\neletrônicos são julgados muito mais rapidamente e, pior, a maioria dos\npedidos físicos nem sequer foram julgados no tempo de 120 dias mostrado\nno gráfico.\nIndo além\nEsse tutorial quis ilustrar o potencial da análise de duração para a\njurimetria. Nem sequer exploramos o tema profundamente. Há muito mais\nquestões que podem ser exploradas, como saber se decisões quem tendem a\nnegar o HC saem mais rapidamente ou não. Igualmente, decisões liminares\nestão sujeitas ao fumus boni iuris e ao periculum in mora.\nPossivelmente, os tempos se invertem quando deferir uma liminar\nsupostamente gera um perigo (HC) ou quando a o indeferimento gera perigo\n(medidas protetivas.)\nA base está disponível\npara você analisá-la e explorar esses outros aspectos.\n\n\n\n",
    "preview": "posts/2022-10-06-sobrevivencia/sobrevivencia_files/figure-html5/unnamed-chunk-10-1.png",
    "last_modified": "2022-10-13T07:49:25-03:00",
    "input_file": "sobrevivencia.knit.md",
    "preview_width": 1248,
    "preview_height": 768
  },
  {
    "path": "posts/welcome/",
    "title": "Jurimetria",
    "description": "Blog voltado à comunidade jurídica interessada em jurimetria.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://github.com/jjesusfilho"
      }
    ],
    "date": "2022-04-29",
    "categories": [],
    "contents": "\n\n\n\n",
    "preview": {},
    "last_modified": "2022-04-29T11:23:40-03:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-04-29-como-baixar-dados-do-tjsp/",
    "title": "Como baixar dados do TJSP",
    "description": "Nesta primeira postagem do blog, falaremos sobre como baixar e estruturar dados do Tribunal de Justiça de São Paulo. Nas próximas, veremos como agregar valor a esses dados e como aplicar técnicas de machine learning  e métodos estatísticos para analisar e fazer predições.",
    "author": [
      {
        "name": "José de Jesus Filho",
        "url": "https://github.com/jjesusfilho"
      }
    ],
    "date": "2022-04-29",
    "categories": [],
    "contents": "\nO texto inaugural mostra como baixar dados processuais do Tribunal de\nJustiça de São Paulo (TJSP), bem como, estruturá-los e deixá-los prontos\npara análise.\nO único pré-requisito é ter noções básicas de programação em R.\nSe você não sabe R e quiser aprender para aplicar à jurimetria, eu\nmantenho um curso Jurimetria\nAplicada.\nInicialmente, vamos instalar o pacote tjsp, o qual tem todas as\nferramentas que você necessita para baixar e organizar os dados do TJSP.\nPara instalar o pacote tjsp, você deve ter o pacote remotes\ninstalado.\nremotes::install_package(\"jjesusfilho/tjsp\")\nO pacote tjsp possui muitas funções para baixar e organizar os dados\ndo TJSP. Ele segue uma sintaxe simples. A maioria das funções começa com\ntjsp_, seguido do verbo indicador da ação, e.g., baixar, seguido da\nsigla do repositório. Basicamente, o sistema esaj, responsável por\ndisponibilizar os dados processuais do TJSP em meio eletrônico, usa\nquatro siglas:\ncjsg para consulta de julgados de segundo grau (busca\njurisprudencia), nesta\npágina.\ncjpg para consulta de julgados de primeiro grau, nesta página.\ncposg para consulta dos dados processuais de segundo grau (dados\nde capa) e movimentação processual, nesta página.\ncpopg para consulta dos dados processuais de primeiro grau (dados\nde capa ) mais movimentação processual, nesta página.\nDessa forma, para baixar um consulta jurisprudencial, você usa a\nfunção tjsp_baixar_cjsg(). Para baixar os dados de capa de\num processo de primeiro grau, você usa a função\ntjsp_baixar_cpopg(). Dentro delas, você vai informar os\nmesmos dados que você informaria na consulta diretamente àquelas\npáginas.\nConsulta jurisprudencial\nA título de exemplo, vamos baixar alguns julgados de segundo grau. Se\nvocê consultar a ajuda da função tjsp_baixar_cjsg(), verá\nque ela tem quase os mesmos parâmetros que você usaria na página do\nTJSP:\nlibrary(tjsp)\n\n?tjsp_baixar_cjsg\ntjsp_baixar_cjsg(\n  livre = \"\",\n  aspas = FALSE,\n  classe = \"\",\n  assunto = \"\",\n  orgao_julgador = \"\",\n  inicio = \"\",\n  fim = \"\",\n  inicio_pb = \"\",\n  fim_pb = \"\",\n  tipo = \"A\",\n  n = NULL,\n  diretorio = \".\"\n)\nO primeiro argumento da função chama-se livre, o qual corresponde à\n“Pesquisa livre` na página referida. Há outros argumentos, como a\nespecificação do assunto ou da classe processual. Hoje usaremos somente\na busca livre e o argumento n, o qual indica o número de páginas. Além\ndeles, indicaremos, no argumento diretorio, onde queremos baixar as\nconsultas:\nVamos fazer um experimento com a palavra “feminicídio”. Vamos criar\num diretório chamado feminicidio (sem acento) e, dentro dele, um outro\nchamado cjsg.\ndir.create(\"feminicidio\")\n\ndir.create(\"feminicidio/cjsg\")\nA consulta por feminicídio resultou em mais de 2500 julgados de\nsegundo grau. Vamos baixar apenas as primeiras 10 páginas da consulta.\nVeja abaixo como ficará a consulta.\ntjsp_baixar_cjsg(livre = \"feminicídio\",\n                 n  = 10,\n                 diretorio = \"feminicidio/cjsg\")\nForam baixados os htmls. Agora vamos ler esses htmls a fim de\nvisualizá-los. O único argumento que você precisa informar é o diretorio\nonde foram salvos os htmls.\ncjsg <- tjsp_ler_cjsg(diretorio = \"feminicidio/cjsg\")\nO resultado é a criação de um dataframe como na imagem abaixo.\n\n\n\nAs colunas lidas são as seguintes:\n\nRows: 200\nColumns: 10\n$ classe          <chr> \"Habeas Corpus Criminal\", \"Apelação Criminal…\n$ assunto         <chr> \"Furto Qualificado\", \"Homicídio Qualificado\"…\n$ relator         <chr> \"Eduardo Abdalla\", \"Camargo Aranha Filho\", \"…\n$ comarca         <chr> \"Mairiporã\", \"Ibiúna\", \"Araçatuba\", \"São Vic…\n$ orgao_julgador  <chr> \"6ª Câmara de Direito Criminal\", \"16ª Câmara…\n$ data_julgamento <date> 2022-04-28, 2022-04-28, 2022-04-28, 2022-04…\n$ data_publicacao <date> 2022-04-28, 2022-04-28, 2022-04-28, 2022-04…\n$ processo        <chr> \"20665325320228260000\", \"0002365312019826023…\n$ ementa          <chr> \"HABEAS CORPUS. Pretendida revogação da pris…\n$ cdacordao       <chr> \"15617778\", \"15617979\", \"15618448\", \"1561631…\n\nConsulta processual\nO próximo passo é consultar os dados de capa desses processos. No\nentanto, para automatizar a coleta de dados processuais, é necessário identificar-se antes\ncom CPF e senha. Se você está cadastrada no esaj, use a função abaixo.\nEla irá abrir um caixa para você incluir seu cpf e senha.\ntjsp_autenticar()\nVamos criar um diretório chamado “cposg” dentro do diretório\n“feminicidio”.\ndir.create(\"feminicidio/cposg\")\nAgora vamos baixar os processos para a pasta criada. Iremos usar a\ncoluna processo do dataframe cjsg. Para usá-la, basta colocar o cifrão\nentre o nome do dataframe e o nome da coluna.\ntjsp_baixar_cposg(cjsg$processo, diretorio = \"feminicidio/cposg\")\nA leitura dos htmls contendo as informações ocorre em quatro etapas.\nInicialmente, nós lemos os dados de capa propriamente ditos, número do\nprocesso, magistrado, comarca, vara etc. Em seguida, lemos os dados das\npartes. Depois lemos a movimentação processual e, por fim, lemos o\ndispositivo do acórdão.\nPara isso, primeiramente listamos todos os arquivos, para então usar\no caminho dos arquivos para “parsear” cada um dos grupos de dados\nmencionados acima. A função abaixo lista todos os htmls.\narquivos <- list.files(\"feminicidio/cposg\",full.names = TRUE)\nDados de capa\nAgora vamos usar esses arquivos para ler os dados de capa.\ndados <- tjsp_ler_dados_cposg(arquivos)\nAbaixo as colunas desses dados:\n\nRows: 230\nColumns: 15\n$ processo       <chr> \"00000417220218260408\", \"00000433520128260383…\n$ cd_processo    <chr> \"RI006OGX10000\", \"RI006K3E10000\", \"RI006KX4S0…\n$ area           <chr> \"Criminal\", \"Criminal\", \"Criminal\", \"Criminal…\n$ assunto        <chr> \"DIREITO PENAL-Crimes contra a vida-Feminicíd…\n$ classe         <chr> \" Recurso em Sentido Estrito\\n\", \" Recurso em…\n$ distribuicao   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ orgao_julgador <chr> \" 16ª Câmara de Direito Criminal\\n\", \" 2ª Câm…\n$ origem         <chr> \"Comarca de Ourinhos / Foro de Ourinhos / 2ª …\n$ outros_numeros <chr> \"\\n                            \\n            …\n$ relator        <chr> \"LEME GARCIA\", \"ANDRÉ CARVALHO E SILVA DE ALM…\n$ revisor        <chr> NA, NA, \"ALBERTO ANDERSON FILHO\", \"RACHID VAZ…\n$ secao          <chr> \" Direito Criminal\\n\", \" Direito Criminal\\n\",…\n$ ultima_carga   <chr> NA, \"\\n                            Origem: Se…\n$ valor_da_acao  <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, N…\n$ volume_apenso  <chr> \"0 / 0\", \"3 / 1\", \"1 / 0\", \"1 / 0\", \"1 / 0\", …\n\nPartes\npartes <- tjsp_ler_partes(arquivos)\n\nRows: 554\nColumns: 4\n$ processo      <chr> \"00000417220218260408\", \"00000417220218260408\"…\n$ tipo_parte    <chr> \"Recorrente:\", \"Recorrido:\", \"Recorrente:\", \"R…\n$ parte         <chr> \"Ministério Público do Estado de São Paulo\", \"…\n$ representante <chr> NA, \"Advogada:&nbsp\\n\\t\\t  \\n\\t\\t\\t  \\n\\t\\t\\t …\n\nMovimentação processual\nO mesmo fazemos com a movimentação processual.\nmovimentacao <- tjsp_ler_movimentacao(arquivos)\nPara visualizar os dados:\n\nRows: 7,518\nColumns: 3\n$ processo     <chr> \"00000417220218260408\", \"00000417220218260408\",…\n$ data         <date> 2022-04-20, 2022-04-20, 2022-04-19, 2022-04-19…\n$ movimentacao <chr> \"Prazo\", \"Publicado em\\n            \\n        \\…\n\nDispositivos\nPor fim, lemos os dispositivos:\ndispositivos <- tjsp_ler_dispositivo(arquivos)\nE visualizamos:\n\nRows: 230\nColumns: 3\n$ processo    <chr> \"00000417220218260408\", \"00000433520128260383\", …\n$ data        <date> 2022-04-12, 2022-04-08, 2022-03-18, 2022-02-17,…\n$ dispositivo <chr> \"Negaram provimento ao recurso. V. U. Sustentou …\n\nNeste tutorial, vimos apenas como baixar e estruturar esses dados em\ndataframes. Nos próximos, veremos como agregar valor a esses dados. Por\nexemplo, podemos classificar as decisões se procedentes ou\nimprocedentes. Podemos analisar o tempo do processo.\nHá muito mais pela frente. Aguarde os próximos tutoriais.\n\n\n\n",
    "preview": "posts/2022-04-29-como-baixar-dados-do-tjsp/feminicidio2.png",
    "last_modified": "2022-10-06T06:24:02-03:00",
    "input_file": "como-baixar-dados-do-tjsp.knit.md",
    "preview_width": 1286,
    "preview_height": 616
  }
]
